<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>An allocator-aware optional type</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2113.3">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p4 {margin: 0.0px 0.0px 6.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p7 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000}
    p.p8 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000}
    p.p9 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p14 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001}
    p.p24 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001; background-color: #21ff06}
    p.p26 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #440045; background-color: #21ff06}
    p.p27 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p28 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p29 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001; min-height: 16.0px}
    p.p30 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; background-color: #21ff06}
    p.p31 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9}
    p.p32 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000}
    p.p33 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #440045}
    p.p34 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p35 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #9d0612}
    p.p36 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p37 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p38 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p39 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69; background-color: #21ff06; min-height: 14.0px}
    p.p40 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #440045; background-color: #21ff06; min-height: 14.0px}
    p.p41 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p42 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p43 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p44 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001; background-color: #21ff06; min-height: 16.0px}
    p.p45 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001; background-color: #21ff06}
    p.p46 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p47 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p48 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 9.3px Times; color: #000000; -webkit-text-stroke: #0000e9; min-height: 11.0px}
    p.p49 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p50 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; min-height: 16.0px}
    p.p51 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p52 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000}
    p.p56 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0); min-height: 14.0px}
    p.p57 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; background-color: #21ff06}
    p.p58 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px 'Apple Color Emoji'; color: #000000; -webkit-text-stroke: #0000e9; min-height: 17.0px}
    p.p60 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Times; color: #000000; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p61 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #000000; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p62 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0); min-height: 16.0px}
    p.p63 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000}
    p.p66 {margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p67 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px 'Lucida Grande'; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p73 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p75 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69}
    p.p76 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000}
    p.p77 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p78 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p79 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p80 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #000000; -webkit-text-stroke: #0000e9}
    p.p81 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; background-color: #21ff06}
    p.p82 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69}
    p.p83 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000}
    p.p84 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p86 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p87 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #440045; background-color: #21ff06}
    li.li28 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    li.li30 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; background-color: #21ff06}
    li.li59 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; min-height: 16.0px}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none}
    span.s3 {font: 13.0px Courier; font-kerning: none}
    span.s4 {font: 14.0px Courier; font-kerning: none}
    span.s5 {font: 12.0px Courier; font-kerning: none}
    span.s6 {font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s7 {font-kerning: none; -webkit-text-stroke: 0px #5b3d2a}
    span.s8 {font-kerning: none; -webkit-text-stroke: 0px #440045}
    span.s9 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0f7001}
    span.s10 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s11 {font-kerning: none; -webkit-text-stroke: 0px #9d0612}
    span.s12 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s13 {font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s14 {font: 12.0px Times; font-kerning: none}
    span.s15 {font-kerning: none; -webkit-text-stroke: 0px #0a4d69}
    span.s16 {font-kerning: none; background-color: #21ff06}
    span.s17 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #0a4d69}
    span.s18 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #440045}
    span.s19 {font-kerning: none; -webkit-text-stroke: 0px #8c550a}
    span.s20 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #9d0612}
    span.s21 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #000000}
    span.s22 {font: 13.3px Times; font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #0f7001}
    span.s23 {font-kerning: none; -webkit-text-stroke: 0px #0f7001}
    span.s24 {font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s25 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s26 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #0000e9}
    span.s27 {font: 14.0px Times; font-kerning: none}
    span.s28 {font: 13.3px Times; font-kerning: none}
    span.s29 {font: 13.3px Times; font-kerning: none; background-color: #21ff06}
    span.s30 {font: 13.3px Times; font-kerning: none; color: #000000; background-color: #21ff06}
    span.s31 {font-kerning: none; color: #000000; background-color: #21ff06}
    span.s32 {font-kerning: none; color: #0000ff; background-color: #21ff06; -webkit-text-stroke: 0px #0000ff}
    span.s33 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none}
    span.s34 {font: 9.4px Times; vertical-align: 4.8px; font-kerning: none}
    span.s35 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #440045}
    span.s36 {font: 9.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s37 {font: 9.4px Times; font-kerning: none}
    span.s38 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s39 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s40 {font: 12.0px 'Lucida Grande'; font-kerning: none}
    span.s41 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #8c550a}
    span.s42 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #9d0612}
    span.s43 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0a4d69}
    span.s44 {-webkit-text-stroke: 0px #000000}
    span.s45 {font: 12.0px 'Lucida Grande'; -webkit-text-stroke: 0px #000000}
    span.s46 {font: 13.3px Times}
    span.s47 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; background-color: #21ff06}
    span.s48 {font: 10.0px Menlo; font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s49 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s50 {font: 9.4px Times; font-kerning: none; background-color: #21ff06}
    span.s51 {font: 13.3px Times; font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #000000}
    span.s52 {font: 10.0px Menlo; font-kerning: none}
    span.s53 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #8c550a}
    span.s54 {font: 13.3px Times; font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #0000e9}
    span.s55 {font: 9.4px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s56 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #440045}
    span.s57 {font: 8.5px Times; vertical-align: -1.8px; font-kerning: none}
    span.s58 {font: 12.0px Times; font-kerning: none; background-color: #21ff06}
    span.s59 {font: 14.0px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s60 {font: 15.6px Times; font-kerning: none; color: #000000}
    span.s61 {font: 14.0px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s62 {font-kerning: none; color: #440045; -webkit-text-stroke: 0px #440045}
    span.s63 {font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #0a4d69}
    span.s64 {font-kerning: none; color: #9d0612; -webkit-text-stroke: 0px #9d0612}
    span.s65 {font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s66 {font: 13.3px Times; font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s67 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s68 {font: 9.4px Times; font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s69 {font-kerning: none; color: #0a4d69}
    span.s70 {font-kerning: none; background-color: #fb0207}
    span.s71 {font: 12.0px Times; font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #440045}
    span.Apple-tab-span {white-space:pre}
    ul.ul1 {list-style-type: none}
    ul.ul2 {list-style-type: hyphen}
  </style>
</head>
<body>
<p class="p1"><span class="s1"><i>Document number: P2047R6<span class="Apple-converted-space"> </span></i></span></p>
<p class="p1"><span class="s1"><i>Audience: LEWG<span class="Apple-converted-space"> </span></i></span></p>
<p class="p2"><span class="s1"><i></i></span><br></p>
<p class="p3"><span class="s2"><a href="mailto:dinka.ranns@gmail.com"><i>Nina Dinka Ranns</i></a></span></p>
<p class="p3"><span class="s2"><a href="mailto:phalpern@halpernwightsoftware.com"><i>Pablo Halpern</i></a></span></p>
<p class="p3"><span class="s2"><a href="mailto:ville.voutilainen@gmail.com"><i>Ville Voutilainen</i></a></span></p>
<p class="p1"><span class="s1"><i>2024-xx-xx</i></span></p>
<p class="p4"><span class="s1"></span><br></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; text-align: center; font: 24.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>An allocator-aware variant type</b></span></h1>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Abstract</b></span></h2>
<p class="p7"><span class="s1">Library types that can potentially hold <i>allocator-aware (AA)</i> objects should, themselves, be allocator-aware. A PMR container, for example, depends on AA types following a known AA protocol so that it (the container) can uniformly manage its memory. Even types that don't manage their own memory, such as </span><span class="s3">tuple</span><span class="s1">, follow the AA rules when they hold one more more AA elements. (A special case is </span><span class="s3">pair</span><span class="s1">, which is not actually AA but effectively follows the rules through special handling in <i>uses-allocator construction</i>.)</span></p>
<p class="p7"><span class="s1">The current definition of </span><span class="s3">std::variant</span><span class="s1"> does not follow the rules for an AA type, even when holding an AA alternative. This limitation makes </span><span class="s3">std::variant</span><span class="s1"> unsuitable for storage in an AA container when memory allocation customization is needed.</span></p>
<p class="p7"><span class="s1">In this paper, we propose a new, allocator-aware </span><span class="s3">std::basic_variant</span><span class="s1"> usable as a container element type of allocator aware containers, and in any other context where allocator propagation and allocator preservation is expected. This new type would not replace the current </span><span class="s3">std:: variant</span><span class="s1"> as the desired behaviour is not compatible with how </span><span class="s3">std:: variant</span><span class="s1"> handles allocator aware types at the moment. We also propose an </span><span class="s3">std::pmr::variant</span><span class="s1"> type which is a specialisation of </span><span class="s3">std::basic_variant</span><span class="s1"> for </span><span class="s3">std::pmr::polymorphic_allocator&lt;&gt;</span><span class="s1">.</span></p>
<p class="p8"><span class="s1">This is a complete proposal with formal wording.</span></p>
<p class="p9"><span class="s1"></span><br></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Motivation and Proposal Summary</b></span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">Working with AA types is generally supported by the standard library. The containers that allocate memory, together with the allocator traits an allocation facilities do so in a way that allows for the containers to also manage the allocator information of the objects they hold, making it possible to specify not just the memory used for the container, but also memory used for the elements of the container. If an element type advertises that it is allocator aware for some allocator type A, and that allocator is a scoped allocator (meaning it provides information not just for the type at hand, but also for any objects such type contains) the container will supply an allocator to its elements at element creation time. However, wrapping an element in std::optional and std::variant breaks this allocation propagation mechanism. Because std::optional and std::variant do not themselves allocate memory, they have not been made AA themselves. They do not require allocator information at creation time, and so none is passed in situations when std::optional or std::variant are placed in an AA containers. Consequently, and AA types places in std::optional or std::variant can not receive allocator information from the container they belong to.<span class="Apple-converted-space"> </span></span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">One may observe that it is indeed possible to pass allocator information to std::optional’s value type and std::variant’s alternative by simply passing them in to either in place constructors or replace methods, but this still suffers from a couple of problems. Firstly, because neither std::optional nor std::variant advertise that they are allocator aware, generic facilities like uses-allocator construction will not do the right thing by default. Secondly, both std::optional and std::variant may internally (re)create their wrapped objects during assignment,<span class="Apple-converted-space">  </span>and there is no way for either the user or the container to ensure the desired allocator is used.<span class="Apple-converted-space"> </span></span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">The last leads us to yet another problematic behaviour of the wrapper types when working with allocator aware elements - not assignment and swap can result in a construction of the wrapper’s element type. Such construction will use the construction allocator propagation traits, as opposed to the allocator propagation policies for assignment and swap. For a user, that makes it very difficult to reason about what the resulting allocator will be and which propagation traits will be used in any given assignment/swap case.</span></h2>
<h2 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">We observe the following properties that need to be modified for std::optional and std::variant to seamlessly work with allocator aware containers, allocator aware facilities, and with allocator aware elements:</span></h2>
<h2 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">- the wrapper types need to advertise they are allocator aware so uses-allocator construction can supply allocator information at construction time and to allow scoped allocators to propagate from the parent container to the wrapped object.</span></h2>
<h2 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">- the allocator information supplied at construction time needs to be preserved by the wrapper type so it can be correctly forwarded to any new object held by the wrapper type.</span></h2>
<h2 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">- the allocator traits need to be checked at assignment/swap operations of the wrapper to ensure that the allocator policies are followed according to the externally specified operations.<span class="Apple-converted-space"> </span></span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px"><span class="s1"></span><br></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1">Modification of std::variant in the above described way is not desirable as it would introduce breaking changes. Instead, a new type std::basic_variant is proposed as described below. Additionally, we also propose an std::pmr::variant type which is a specialisation of std::basic_variant for std::pmr::polymorphic_allocator&lt;&gt;.</span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Design decisions:</b></span></h2>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s4"><b>Basic_variant</b></span><span class="s1"><b> supports non-scoped propagating allocators<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p14"><span class="s1">There are two ways of viewing </span><span class="s5">basic_variant</span><span class="s1"> from allocator propagation perspective : <br>
#1 </span><span class="s5">basic_varian</span><span class="s1"> is like an </span><span class="s5">std::tuple</span><span class="s1">, i.e. it only accepts the allocator at construction so it can forward it to the value_type object. One can use a non-scoped propagation allocator, and when using a scoped propagation allocator </span><span class="s5">basic_varian</span><span class="s1"> will not "consume" an allocator level. A variant object is in a way like a tuple object as it does not use the allocator itself, it only passes it into the value_type object. <br>
#2 </span><span class="s5">basic_variant</span><span class="s1"> is like an </span><span class="s5">std::vector</span><span class="s1">, i.e. it is a container of one or zero elements, and one should use a scoped propagating allocator if one wants the value_type object to use the allocator. In this approach </span><span class="s5">basic_variant</span><span class="s1"> will "consume" an allocator level. Using non-scoped propagating allocators makes little sense in this scenario.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">The proposal implements #1 as </span><span class="s5">basic_variant</span><span class="s1"> itself does not allocate any memory so it makes little sense for it to consume an allocator level.<span class="Apple-converted-space">  </span>The allocator in basic_variant is simply stored so it can be used by any alternative that requires it.</span></p>
<p class="p15"><span class="s1"><b>Variant and basic_variant interoperability</b></span></p>
<p class="p16"><span class="s1"></span><br></p>
<p class="p11"><span class="s1">This proposal does not propose any<span class="Apple-converted-space">  </span>implicit or explicit conversion between std::variant and std::basic_variant.<span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s1"><b></b></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Allocator overhead</b></span></h3>
<p class="p18"><span class="s1">Allocator overhead can be removed in two cases</span></p>
<p class="p18"><span class="s1">- if all alternatives are not allocator aware</span></p>
<p class="p18"><span class="s1">- is allocator_traits&lt;Allocator&gt;::is_always_equal::value == true</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p18"><span class="s1">In the former case, allocator is simply not needed. In the latter case, there is no need to store or pass in the allocator as the default allocator will do. The paper doesn’t standardise such optimisation, it is left as a QOI. Note that the above cases reduce to std::variant behaviour.</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p20"><span class="s1"><b></b></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Default constructor considerations</b></span></h3>
<p class="p14"><span class="s1">Uses_allocator construction is always used in case the default allocator construction produces different allocators each time. Possible optimisation opportunity for allocators which have is_always_equal set to true, but no benefit in triviality or constexpr - uses_allocator construction will be constexpr if it can be constexpr either way. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant constexpr considerations would only depend on the constexpr construction of the 0th alternative.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">No conditional triviality of the default constructor is possible - the internal state needs to be initialised.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">Because default constructor has to explicitly specify the allocator, unless is_always_equal==true, the default constructor is noexcept if 0th alternative is not AA or is_always_equal==true, and default construction of 0th alternative is noexcept.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy constructor considerations</b></span></h3>
<p class="p14"><span class="s1">Copy construction does not do uses_allocator construction - the type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator is always equal and both the allocator and the constructed type can be trivially copy constructed. If allocator is not always equal, we need to check the traits to get the right allocator and that initialisation can not be trivial. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move constructor considerations</b></span></h3>
<p class="p14"><span class="s1">Move construction does not do uses_allocator construction - the type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator and the constructed type can be trivially move constructed. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value constructor considerations</b></span></h3>
<p class="p14"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">The paper does not propose exception specification on this value constructor and considers it QOI</span></p>
<p class="p14"><span class="s1">Exception specification considerations<span class="Apple-converted-space">  </span>: <br>
- for non AA type, the exception specification is equivalent to is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, to get a possibly no throw construction, we need to delegate to plain copy/move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal. If this constructor checked for allocators being always equal before deciding whether to do uses allocator construction or not, it would make sense for all inplace constructors and allocator extended constructors to do the same. This paper does not propose such considerations.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy assignment operator considerations</b></span></h3>
<p class="p14"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. In addition to std::variant’s triviality requirements, triviality can only happen if allocator is always equal and it is a trivially copyable type. The condition for the copy construction vs variant move construction is as follows : <br>
- if a copy construction can't throw do copy construction <br>
- if move construction can throw do copy construction as the move construction doesn't bring any benefits <br>
- otherwise, do move construction.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">With the introduction of allocators, we now have to consider when we can do plain copy construction and when allocator extended construction is needed. If type is non AA, we can do plain copy construction. If the type is AA and allocator is always equal, we can also do plain copy construction. Note that, for allocator is always equal case, plain copy construction and allocator copy construction will effectively result in the same allocator. We do not consider the possibility of doing non allocator extended copy construction for the case where the copy assignment allocator propagation matches the resulting allocator at copy construction as that case can't be checked at compile time.</span></p>
<p class="p14"><span class="s1">In all other cases, copy construction must use allocator extended copy construction to guarantee that the right allocator is used. We assume such cases are always throwing.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">Move assignment from a temporary basic_variant must construct the temporary object with uses-allocator construction to ensure correct allocator is used.<span class="Apple-converted-space">  </span>A possible optimisation is for the case when allocators are always equal or if POCMA=true<span class="Apple-converted-space">  </span>- such temporary could be constructed with a non allocator extended constructor. This paper does not propose such optimisation.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move assignment operator<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p14"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. In addition to usual triviality requirements, triviality can only happen if the allocator is propagated for move assignment(POCMA=true) or if the allocator is always equal. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and triviality only depends on the triviality of the alternative operations. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">The exception specification needs to consider assignment and construction operations. For AA types, move construction can be done directly if the allocator is always equal or if POCMA=true. Otherwise, the move construction needs to explicitly specify the allocator and we consider such move construction to always be possibly throwing.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value assignment operator</b></span></h3>
<p class="p14"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator. Exception specification : <br>
- for non AA type, the exception specification is equivalent to is_nothrow_assignable_v&lt;Tj, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal. <br>
Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and exception specification depends only on the alternatives This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Member swap</b></span></h3>
<p class="p14"><span class="s1">First the allocator is possibly modified based on the traits, then the swap/construction is done as normal. Exception specification : To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal or if propagate_on_container_swap == true (for such a type, the resulting allocator in move construction is the required allocator as move construction always propagates the allocator.) This means that swap can only be noexcept if <br>
- is_nothrow_move_constructible_v&lt;Ti, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Ti, T&gt; for all i, and <br>
- allocator is always equal or propagate_on_container_swap == true<span class="Apple-converted-space"> </span></span></p>
<p class="p14"><span class="s1">Note that swap has undefined behaviour if (allocator is always equal or propagate_on_container_swap == true) condition is not satisfied, so this condition is not reflected in the exception specification.</span></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Proposed wording</b></span></h2>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #000000; -webkit-text-stroke: #0000e9"><span class="s1"><b>Modify 22.6.2</b></span><span class="s6"><b> Header &lt;variant&gt; synopsis</b></span><span class="s1"><b> [variant.syn]</b></span></h3>
<p class="p23"><span class="s1"><i>// mostly freestanding</i></span></p>
<p class="p18"><span class="s7">#include</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1">compare</span><span class="s8">&gt;</span><span class="s1"><span class="Apple-converted-space">              </span></span><span class="s9"><i>// see </i></span><span class="s10"><i>[compare.syn]</i></span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">namespace</span><span class="s6"> std </span><span class="s11">{</span></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.variant]</i></span><span class="s1"><i>, class template </i></span><span class="s14">variant</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">class</span><span class="s1"> variant;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p25"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.basic.variant]</i></span><span class="s1"><i>, class template basic_</i></span><span class="s14">variant</span></p>
<p class="p26"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s1">&lt;class Allocator, </span><span class="s15">class</span><span class="s1">...</span><span class="s6"> Types</span><span class="s1">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span></span><span class="s17">class</span><span class="s16"> basic_variant;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.helper]</i></span><span class="s1"><i>, variant helper classes</i></span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">struct</span><span class="s1"> variant_size;<span class="Apple-converted-space">                        </span></span><span class="s9"><i>// not defined</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">struct</span><span class="s6"> variant_size</span><span class="s8">&lt;</span><span class="s1">const</span><span class="s6"> T</span><span class="s8">&gt;</span><span class="s6">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> size_t variant_size_v </span><span class="s8">=</span><span class="s1"> variant_size</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;::</span><span class="s1">value;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">struct</span><span class="s1"> variant_size</span><span class="s8">&lt;</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span></span><span class="s17">struct</span><span class="s16"> variant_size</span><span class="s18">&lt;basic_</span><span class="s16">variant</span><span class="s18">&lt;Allocator, </span><span class="s16">Types</span><span class="s18">...&gt;&gt;</span><span class="s16">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> T</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">struct</span><span class="s1"> variant_alternative; <span class="Apple-converted-space">      </span></span><span class="s9"><i>// not defined</i></span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> T</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">struct</span><span class="s1"> variant_alternative</span><span class="s8">&lt;</span><span class="s1">I, </span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&gt;</span><span class="s1">;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> T</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">using</span><span class="s1"> variant_alternative_t </span><span class="s8">=</span><span class="s1"> </span><span class="s15">typename</span><span class="s1"> variant_alternative</span><span class="s8">&lt;</span><span class="s1">I, T</span><span class="s8">&gt;::</span><span class="s1">type;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">struct</span><span class="s1"> variant_alternative</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span></span><span class="s17">struct</span><span class="s16"> variant_alternative</span><span class="s18">&lt;</span><span class="s16">I, basic_variant</span><span class="s18">&lt;Allocator, </span><span class="s16">Types</span><span class="s18">...&gt;&gt;</span><span class="s16">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">inline</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> size_t variant_npos </span><span class="s8">=</span><span class="s1"> </span><span class="s8">-</span><span class="s19">1</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.get]</i></span><span class="s1"><i>, value access</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> holds_alternative</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> holds_alternative</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant</span><span class="s18">&lt;</span><span class="s21">Allocator, </span><span class="s16">Types</span><span class="s18">...&gt;&amp;</span><span class="s20">)</span><span class="s16"> </span><span class="s17">noexcept</span><span class="s16">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                                          </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;&amp;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                                        </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                                    </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;&amp;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                                  </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p29"><span class="s1"><i></i></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                                          </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                                        </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                                    </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;&amp;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">      </span>get</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">&amp;&amp;</span><span class="s20">)</span><span class="s16">; <span class="Apple-converted-space">                                  </span></span><span class="s22"><i>// freestanding-deleted</i></span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                              </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                            </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                  </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p29"><span class="s1"><i></i></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                              </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                            </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                  </span></span><span class="s9"><i>// freestanding-deleted</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">const</span><span class="s16"> T</span><span class="s18">&amp;&amp;</span><span class="s16"> get</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">&amp;&amp;</span><span class="s20">)</span><span class="s16">; <span class="Apple-converted-space">                </span></span><span class="s22"><i>// freestanding-deleted</i></span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">*</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">      </span>get_if</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">*</span><span class="s20">)</span><span class="s16"> </span><span class="s17">noexcept</span><span class="s16">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.relops]</i></span><span class="s1"><i>, relational operators</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">==</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">!=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&lt;</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&lt;=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&gt;=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">requires</span><span class="s6"> </span><span class="s11">(</span><span class="s13">three_way_comparable</span><span class="s8">&lt;</span><span class="s6">Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s8">&amp;&amp;</span><span class="s6"> </span><span class="s8">...</span><span class="s11">)</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s8">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">&gt;...&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">operator</span><span class="s8">&lt;=&gt;</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s8">&gt;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">bool</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">==</span><span class="s11">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s8">&gt;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">bool</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">!=</span><span class="s11">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s8">&gt;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">bool</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">&lt;</span><span class="s11">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s8">&gt;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">bool</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s8">&gt;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">bool</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">&lt;=</span><span class="s11">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s8">&gt;</span></p>
<p class="p24"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s16">constexpr</span><span class="s21"> </span><span class="s16">bool</span><span class="s21"> </span><span class="s16">operator</span><span class="s18">&gt;=</span><span class="s20">(</span><span class="s16">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s20">)</span><span class="s21">;</span></p>
<p class="p30"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">AllocatorLhs, AllocatorRhs, </span><span class="s15">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s15">requires</span><span class="s6"> </span><span class="s11">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s13">three_way_comparable</span></a></span><span class="s8">&lt;</span><span class="s6">Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s8">&amp;&amp;</span><span class="s6"> </span><span class="s8">...</span><span class="s11">)</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s8">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">&gt;...&gt;</span></p>
<p class="p24"><span class="s21"><span class="Apple-converted-space">      </span></span><span class="s16">operator</span><span class="s18">&lt;=&gt;</span><span class="s20">(</span><span class="s16">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s20">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p31"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s23"><i>// </i></span><span class="s1"><i>[variant.visit]</i></span><span class="s23"><i>, visitation</i></span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> Visitor, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Variants</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> <i>see below</i> visit</span><span class="s11">(</span><span class="s1">Visitor</span><span class="s8">&amp;&amp;</span><span class="s1">, Variants</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> R, </span><span class="s15">class</span><span class="s1"> Visitor, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Variants</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> R visit</span><span class="s11">(</span><span class="s1">Visitor</span><span class="s8">&amp;&amp;</span><span class="s1">, Variants</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.monostate]</i></span><span class="s1"><i>, class </i></span><span class="s14">monostate</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">struct</span><span class="s1"> monostate;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.monostate.relops]</i></span><span class="s1"><i>, </i></span><span class="s14">monostate</span><span class="s1"><i> relational operators</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">bool</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">==</span><span class="s11">(</span><span class="s6">monostate, monostate</span><span class="s11">)</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s6">;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> strong_ordering </span><span class="s15">operator</span><span class="s8">&lt;=&gt;</span><span class="s11">(</span><span class="s1">monostate, monostate</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.specalg]</i></span><span class="s1"><i>, specialized algorithms</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">void</span><span class="s1"> swap</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1">, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s1"><i>see below</i></span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p30"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p32"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s17">constexpr</span><span class="s21"> </span><span class="s17">void</span><span class="s21"> swap</span><span class="s20">(</span><span class="s16">basic_variant&lt;Allocator, </span><span class="s21">Types</span><span class="s18">...&gt;&amp;</span><span class="s21">, </span><span class="s16">basic_variant&lt;Allocator, </span><span class="s21">Types</span><span class="s18">...&gt;&amp;</span><span class="s20">)</span><span class="s21"> </span><span class="s17">noexcept</span><span class="s20">(</span><span class="s21"><i>see below</i></span><span class="s20">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.bad.access]</i></span><span class="s1"><i>, class </i></span><span class="s14">bad_variant_access</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">class</span><span class="s1"> bad_variant_access;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p23"><span class="s12"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s13"><i>[variant.hash]</i></span><span class="s1"><i>, hash support</i></span></p>
<p class="p24"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">struct</span><span class="s6"> hash;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">struct</span><span class="s1"> hash</span><span class="s8">&lt;</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;</span><span class="s1">;</span></p>
<p class="p33"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s17">template</span><span class="s16">&lt;</span><span class="s21">class Allocator, </span><span class="s17">class</span><span class="s16">...</span><span class="s21"> Types</span><span class="s16">&gt;</span><span class="s21"> </span><span class="s17">struct</span><span class="s21"> hash</span><span class="s16">&lt;basic_</span><span class="s21">variant</span><span class="s16">&lt;Allocator, </span><span class="s21">Types</span><span class="s16">...&gt;&gt;</span><span class="s21">;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">template</span><span class="s8">&lt;&gt;</span><span class="s1"> </span><span class="s15">struct</span><span class="s1"> hash</span><span class="s8">&lt;</span><span class="s1">monostate</span><span class="s8">&gt;</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span>namespace pmr {</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    <span class="Apple-tab-span">	</span></span>using variant = basic_variant&lt;polymorphic_allocator&lt;byte&gt;, Types…&gt;;</span></p>
<p class="p34"><span class="s1"><span class="Apple-converted-space">  </span>}<span class="Apple-converted-space"> </span></span></p>
<p class="p35"><span class="s1">}</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p35"><span class="s1">Insert new section after <a href="https://eel.is/c++draft/variant#variant"><span class="s24">22.6.3</span></a></span><span class="s25"> Class template variant</span><span class="s24"> <a href="https://eel.is/c++draft/variant.variant"><span class="s1">[variant.variant]</span></a></span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p37"><span class="s16"><b>22.6.x Class template basic_variant</b></span><span class="s26"><b> [variant.basic.variant]</b></span></p>
<p class="p38"><span class="s6">X.x.x. 1 <b>General</b></span><span class="s27"><b> </b><a href="https://eel.is/c++draft/variant.variant.general"><span class="s28"><b>[</b></span></a></span><span class="s1"><b>variant.basic.variant.general]</b></span></p>
<p class="p39"><span class="s1"></span><br></p>
<p class="p27"><span class="s1">namespace</span><span class="s6"> std </span><span class="s11">{</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8"> </span><span class="s6">Allocator, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">class</span><span class="s1"> basic_variant </span><span class="s11">{</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">  </span></span><span class="s1">public</span><span class="s8">:</span></p>
<p class="p40"><span class="s1"></span><br></p>
<p class="p41"><span class="s15"><span class="Apple-converted-space">    </span>using</span><span class="s1"> allocator_type<span class="Apple-converted-space">  </span></span><span class="s8">=</span><span class="s1"> Allocator;</span></p>
<p class="p42"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s13"><i>[</i></span></a></span><span class="s28"><i>variant.basic.ctor]</i></span><span class="s9"><i>, constructors</i></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">()</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s1"><i>see below</i></span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s1">basic_variant</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s1"><i>see below</i></span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s1">T</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s6"> U, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> U, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p44"><span class="s1"><i></i></span><br></p>
<p class="p45"><span class="s1"><i>// allocator-extended constructors</i></span></p>
<p class="p41"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a</span><span class="s11">)</span><span class="s1"> ;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s15">const</span><span class="s1"> basic_variant</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s11">basic_variant</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s1">T</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s6"> U, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> U, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s6"> a, </span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s28"><i>variant.basic.dtor]</i></span><span class="s9"><i>, destructor</i></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s8">~</span><span class="s1">variant</span><span class="s11">()</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s28"><i>variant.basic.assign]</i></span><span class="s9"><i> assignment</i></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> variant</span><span class="s8">&amp;</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> variant</span><span class="s8">&amp;</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s6">variant</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">constexpr</span><span class="s6"> variant</span><span class="s8">&amp;</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s6">T</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s28"><i>variant.basic.mod]</i></span><span class="s9"><i>, modifiers</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> emplace</span><span class="s11">(</span><span class="s1">Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s6"> U, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> emplace</span><span class="s11">(</span><span class="s1">initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span><span class="s1"> emplace</span><span class="s11">(</span><span class="s1">Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> U, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">        </span>emplace</span><span class="s11">(</span><span class="s1">initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s28"><i>variant.basic.status]</i></span><span class="s9"><i>, value status</i></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> valueless_by_exception</span><span class="s11">()</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> size_t index</span><span class="s11">()</span><span class="s6"> </span><span class="s1">const</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s6">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p46"><span class="s9"><i><span class="Apple-converted-space">   </span>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s1"><i>variant.basic.al]</i></span><span class="s9"><i>, allocator</i></span></p>
<p class="p41"><span class="s1"><span class="Apple-converted-space">    </span>allocator_type get_allocator</span><span class="s11">()</span><span class="s1"> </span><span class="s15">const</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s28"><i>variant.basic.swap]</i></span><span class="s9"><i>, swap</i></span></p>
<p class="p27"><span class="s6"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">void</span><span class="s6"> swap</span><span class="s11">(</span><span class="s6">variant</span><span class="s8">&amp;</span><span class="s11">)</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p38"><span class="s12"><span class="Apple-converted-space">    </span></span><span class="s9"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s10"><i>[</i></span></a></span><span class="s28"><i>variant.basic.visit]</i></span><span class="s9"><i> visitation</i></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> Self, </span><span class="s15">class</span><span class="s1"> Visitor</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">decltype</span><span class="s11">(</span><span class="s15">auto</span><span class="s11">)</span><span class="s1"> visit</span><span class="s11">(</span><span class="s15">this</span><span class="s1"> Self</span><span class="s8">&amp;&amp;</span><span class="s1">, Visitor</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> R, </span><span class="s15">class</span><span class="s1"> Self, </span><span class="s15">class</span><span class="s1"> Visitor</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s15">constexpr</span><span class="s1"> R visit</span><span class="s11">(</span><span class="s15">this</span><span class="s1"> Self</span><span class="s8">&amp;&amp;</span><span class="s1">, Visitor</span><span class="s8">&amp;&amp;</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s1">private</span><span class="s8">:</span></p>
<p class="p41"><span class="s1"><span class="Apple-converted-space">   </span>allocator_type <i>alloc</i>; <span class="Apple-converted-space">        </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s11">}</span><span class="s1">;</span></p>
<p class="p35"><span class="s16">}</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p49"><span class="s16">Any instance of basic_variant at any given time either holds a value of one of its alternative types or holds no value. When an instance of basic_variant holds a value of alternative type T, it means that a value of type T, referred to as the </span><span class="s29">basic_variant</span><span class="s16"> object's <a href="https://eel.is/c++draft/variant#def:contained_value,variant"><span class="s28"><i>contained value</i></span></a>, is allocated within the storage of the </span><span class="s29">basic_variant</span><span class="s16"> object<a href="https://eel.is/c++draft/variant#variant.general-1.sentence-2"><span class="s28">.</span></a> Implementations are not permitted to use additional storage, such as dynamic memory, to allocate the contained value.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p49"><span class="s16">All types in Types shall meet the <i>Cpp17Destructible</i> requirements (Table </span><span class="s26">35)</span></p>
<p class="p50"><span class="s1"></span><br></p>
<p class="p51"><span class="s1">A program that instantiates the definition of basic_variant with less than 2 template arguments is ill-formed.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p52"><span class="s30">Template argument Allocator shall satisfy</span><span class="s31"> the <i>Cpp17Allocator </i>requirements (</span><span class="s32">16.4.4.6.1</span><span class="s31">). </span><span class="s16">A an instance of Allocator is maintained by the basic_variant object during the lifetime of the object or until the allocator is replaced. The allocator instance is set at object creation time and may be replaced only via assignment or swap as specified below. The allocator instance is used to pass to uses-allocator construction of an alternative as specified below.</span></p>
<p class="p50"><span class="s1"></span><br></p>
<p class="p49"><span class="s16">If a program declares an explicit or partial specialization of </span><span class="s29">basic_variant</span><span class="s16">, the program is ill-formed, no diagnostic required</span></p>
<h4 style="margin: 0.0px 0.0px 16.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px"><span class="s1"><b></b></span><br></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s1"><b>X.x.x.2 </b></span><span class="s6"><b>Constructors </b></span><span class="s28"><b>[variant.basic.ctor]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s1">In the descriptions that follow, let </span><span class="s28"><i>i</i></span><span class="s1"> be in the range [</span><span class="s19">0</span><span class="s1">, </span><span class="s15">sizeof</span><span class="s8">...</span><span class="s11">(</span><span class="s1">Types</span><span class="s11">)</span><span class="s1">), and </span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s1"> be the <i>i</i></span><span class="s34">th</span><span class="s1"> type in Types.</span></h4>
<p class="p27"><span class="s1">constexpr</span><span class="s6"> basic_variant</span><span class="s11">()</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_default_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33">0</span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized. If </span><span class="s28">allocator_traits</span><span class="s35">&lt;</span><span class="s28">Allocator</span><span class="s35">&gt;::is_always_equal::</span><span class="s1">value is false,<span class="Apple-converted-space">  </span>an alternative of type </span><span class="s28">T</span><span class="s33">0</span><span class="s1"> is constructed by uses-allocator construction with allocator </span><span class="s8">alloc</span><span class="s1"> and no constructor arguments. Otherwise, </span><span class="s28">T</span><span class="s33">0</span><span class="s1"> is value-initialized.<span class="Apple-tab-span">	</span></span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: valueless_by_exception</span><span class="s11">()</span><span class="s1"> is </span><span class="s19">false</span><span class="s1"> and index</span><span class="s11">()</span><span class="s1"> is </span><span class="s19">0</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by the value-initialization of </span><span class="s28">T</span><span class="s33">0</span><span class="s36">.</span></p>
<p class="p51"><span class="s36"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Remarks</i>: This function is </span><span class="s15">constexpr</span><span class="s1"> if and only if the selected constructor of the alternative type </span><span class="s28">T</span><span class="s33">0</span><span class="s37"> </span><span class="s1">and the allocator alloc is constexpr-suitable (<a href="https://eel.is/c++draft/dcl.constexpr"><span class="s10">[dcl.constexpr]</span></a>)<a href="https://eel.is/c++draft/variant#ctor-6.sentence-1"><span class="s28">.</span></a> The exception specification is equivalent to is_nothrow_default_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33">0</span><span class="s8">&gt; &amp;&amp; <span class="Apple-converted-space">  </span>(</span><span class="s38">allocator_traits&lt;Allocator&gt;::is_always_equal::</span><span class="s28">value || !</span><span class="s38">uses_allocator_v&lt;remove_cv_t &lt;</span><span class="s28">T</span><span class="s33">0</span><span class="s38">&gt;&gt;).</span><span class="s14"><span class="Apple-tab-span">	</span>[<i>Note </i></span><span class="s39"><i>:</i></span><span class="s40"> </span><span class="s14">See also class monostate<a href="https://eel.is/c++draft/variant#ctor-6.sentence-3"><span class="s6">.</span></a> — <i>end note</i>]</span></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p28"><span class="s15">constexpr</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant</span><span class="s8">&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: </span><span class="s28">If allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, alloc is default-initialized. Otherwise, alloc is direct-initialized with an </span><span class="s38">allocator_traits&lt;Allocator&gt;::select_on_container_copy_construction(w.get_allocator()).</span><span class="s28"> </span><span class="s1">If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s8">&lt;</span><span class="s1">j</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1">, where j is w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()<a href="https://eel.is/c++draft/variant#ctor-7.sentence-1"><span class="s38">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value.</span></p>
<p class="p51"><span class="s13"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5127"><span class="Apple-tab-span">	</span></a></span><span class="s1"><i>Throws</i>: Any exception thrown by direct-initializing any </span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s1"> for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p51"><span class="s13"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Remarks</i>: This constructor is defined as deleted unless is_copy_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i><a href="https://eel.is/c++draft/variant#ctor-9.sentence-1"><span class="s6">.</span></a></span><span class="s1"> This constructor is trivial if</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s28">is_trivially_copy_constructible_v</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s35">&gt;</span><span class="s28"> is </span><span class="s41">true</span><span class="s28"> for all <i>i</i>,</span></p>
<p class="p57"><span class="s6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and</span></p>
<p class="p57"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_copy_constructible_v&lt;Allocator&gt; is true</span></p>
<p class="p58"><span class="s1"></span><br></p>
<p class="p30"><span class="s15">constexpr</span><span class="s6"> </span><span class="s1">basic_variant</span><span class="s11">(</span><span class="s1">basic_variant </span><span class="s8">&amp;&amp;</span><span class="s6"> w</span><span class="s11">)</span><span class="s6"> </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i><a href="https://eel.is/c++draft/variant#ctor-10.sentence-1"><span class="s6">.</span></a></span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: </span><span class="s38">alloc is direct-initialized with w.get_allocator(). </span><span class="s1">If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s8">&lt;</span><span class="s1">j</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">std</span><span class="s8"> :: </span><span class="s1">move</span><span class="s11">(</span><span class="s1">w</span><span class="s11">))</span><span class="s1">, where j is w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()<a href="https://eel.is/c++draft/variant#ctor-11.sentence-1"><span class="s38">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value<a href="https://eel.is/c++draft/variant#ctor-11.sentence-2"><span class="s28">.</span></a></span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by move-constructing any </span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s1"> for all </span><span class="s28"><i>i</i><a href="https://eel.is/c++draft/variant#ctor-12.sentence-1"><span class="s6">.</span></a></span></p>
<p class="p51"><span class="s1"><a href="https://eel.is/c++draft/variant#ctor-12.sentence-1"><span class="Apple-tab-span">	</span></a><i>Remarks</i>: The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> for all </span><span class="s28"><i>i</i></span><span class="s1">. This constructor is trivial if :</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-</span><span class="s28"> is_trivially_move_constructible_v&lt;T</span><span class="s33"><i>i</i></span><span class="s28">&gt; is true for all <i>i</i>, and</span></p>
<p class="p49"><span class="s29"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v&lt;Allocator&gt; is true</span></p>
<ul class="ul1">
  <li class="li59"></li>
</ul>
<p class="p27"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">constexpr</span><span class="s6"> basic_variant</span><span class="s11">(</span><span class="s6">T</span><span class="s8">&amp;&amp;</span><span class="s6"> t</span><span class="s11">)</span><span class="s6"> ;</span></p>
<p class="p51"><span class="s28">Let T</span><span class="s33"><i>j</i></span><span class="s28"> be a type that is determined as follows: build an imaginary function <i>FUN</i></span><span class="s42">(</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s42">)</span><span class="s28"> for each alternative type T</span><span class="s33"><i>i</i></span><span class="s28"> for which T</span><span class="s33"><i>i</i></span><span class="s28"> x</span><span class="s42">[]</span><span class="s28"> </span><span class="s35">=</span><span class="s28"> </span><span class="s42">{</span><span class="s28">std</span><span class="s35"> :: </span><span class="s28">forward</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s42">(</span><span class="s28">t</span><span class="s42">)}</span><span class="s28">; is well-formed for some invented variable x<a href="https://eel.is/c++draft/variant#ctor-14.sentence-1"><span class="s38">.</span></a> The overload <i>FUN</i></span><span class="s42">(</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s42">)</span><span class="s28"> selected by overload resolution for the expression <i>FUN</i></span><span class="s42">(</span><span class="s28">std</span><span class="s35"> :: </span><span class="s28">forward</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s42">(</span><span class="s28"> t</span><span class="s42">))</span><span class="s28"> defines the alternative T</span><span class="s33"><i>j</i></span><span class="s28"> which is the type of the contained value after construction.</span></p>
<p class="p51"><span class="s28"><i><span class="Apple-tab-span">	</span>Constraints</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s28"> is nonzero,</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s35">&lt;</span><span class="s28">remove_cvref_t</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s28">, variant</span><span class="s35">&gt;</span><span class="s28"> is </span><span class="s41">false</span><span class="s28">,</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- remove_cvref_t</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s28"> is neither a specialization of in_place_type_t nor a specialization of in_place_index_t,</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s28">, T</span><span class="s35">&gt;</span><span class="s28"> is </span><span class="s41">true</span><span class="s28">, and<span class="Apple-tab-span">	</span>the expression <i>FUN</i></span><span class="s42">(</span><span class="s28"> std</span><span class="s35"> :: </span><span class="s28">forward</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s42">(</span><span class="s28">t</span><span class="s42">))</span><span class="s28"> (with <i>FUN</i> being the above-mentioned set of imaginary functions) is well-formed.<span class="Apple-converted-space"> </span></span></p>
<p class="p28"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[<i>Note </i>:</span><span class="s40"> </span></p>
<p class="p28"><span class="s40"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">basic_variant</span><span class="s8">&lt;</span><span class="s1">string, string</span><span class="s8">&gt;</span><span class="s1"> v</span><span class="s11">(</span><span class="s19">"abc"</span><span class="s11">)</span><span class="s1">;</span></p>
<ul class="ul1">
  <ul class="ul2">
    <li class="li28"><span class="s44"><span class="Apple-tab-span">	</span></span><span class="s45"> <span class="Apple-converted-space">    </span></span><span class="Apple-converted-space">  </span><span class="s1">is ill-formed, as both alternative types have an equally viable constructor for the argument<a href="https://eel.is/c++draft/variant#ctor-15.5.sentence-2">.</a> — <i>end note</i>]</span></li>
  </ul>
</ul>
<p class="p51"><span class="s46"><i><span class="Apple-tab-span">	</span>E</i></span><span class="s28"><i>ffects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span>If allocator_traits&lt;Allocator&gt;::is_always_equal::value is false, an alternative of type T</span><span class="s33">j</span><span class="s28"> is constructed by uses-allocator construction with allocator alloc and std::forward&lt;T&gt;(t). Otherwise, an alternative of type T</span><span class="s33">j </span><span class="s28">is direct-non-list-initialized with std</span><span class="s35">::</span><span class="s28">forward</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s42">(</span><span class="s28">t</span><span class="s42">)</span><span class="s28">.</span></p>
<p class="p51"><span class="s28"><i><span class="Apple-tab-span">	</span>Postconditions</i>: holds_alternative</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s35">&gt;</span><span class="s42">(</span><span class="s35">*</span><span class="s43">this</span><span class="s42">)</span><span class="s28"> is </span><span class="s41">true</span><span class="s28">.</span></p>
<p class="p51"><span class="s28"><i><span class="Apple-tab-span">	</span>Throws</i>: Any exception thrown by the initialization of the selected alternative T</span><span class="s33"><i>j</i></span><span class="s37"><i>.</i></span></p>
<p class="p49"><span class="s29"><i><span class="Apple-tab-span">	</span>Remarks</i>: If Allocator’s default constructor and T</span><span class="s47"><i>j</i></span><span class="s29">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor</span></p>
<p class="p60"><span class="s1"></span><br></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> </span><span class="s6">basic_variant</span><span class="s11">(</span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- There is exactly one occurrence of T in Types</span><span class="s8">...</span><span class="s1"> and</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s8">&lt;</span><span class="s1">T, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: </span><span class="s38">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s28">An alternative of type T is constructed by uses-allocator construction with allocator </span><span class="s35">alloc</span><span class="s28"> and</span><span class="s1"> std</span><span class="s8"> :: </span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">Args</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">args</span><span class="s11">)</span><span class="s8">...</span><span class="s1"> .</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: holds_alternative</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s8">*</span><span class="s15">this</span><span class="s11">)</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T.</span></p>
<p class="p49"><span class="s16"><span class="Apple-tab-span">	</span><i>Remarks</i>: If Allocator’s default constructor and T’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p61"><span class="s1"></span><br></p>
<p class="p27"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s6"> U, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> </span><span class="s6">basic_variant</span><span class="s11">(</span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1"> il, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- There is exactly one occurrence of T in Types</span><span class="s8">...</span><span class="s1"> and</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s8">&lt;</span><span class="s1">T, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;&amp;</span><span class="s1">, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p57"><span class="s38"><span class="Apple-tab-span">	</span><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span>An alternative of type T is constructed by uses-allocator construction with allocator alloc and</span><span class="s38"> il, std</span><span class="s35"> :: </span><span class="s38">forward</span><span class="s35">&lt;</span><span class="s38">Args</span><span class="s35">&gt;</span><span class="s42">(</span><span class="s38"> args</span><span class="s42">)</span><span class="s35">...</span><span class="s38"> .</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: holds_alternative</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s8">*</span><span class="s15">this</span><span class="s11">)</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T.</span></p>
<p class="p49"><span class="s16"><span class="Apple-tab-span">	</span></span><span class="s29"><i>Remarks</i>: If Allocator’s default constructor and T’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p21"><span class="s28"></span><br></p>
<p class="p28"><span class="s48">t</span><span class="s15">emplate</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> </span><span class="s6">basic_variant</span><span class="s11">(</span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- I is less than </span><span class="s15">sizeof</span><span class="s8">...</span><span class="s11">(</span><span class="s1">Types</span><span class="s11">)</span><span class="s1"> and</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>I</i></span><span class="s1">, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p57"><span class="s38"><span class="Apple-tab-span">	</span><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span>An alternative of type</span><span class="s38"> T</span><span class="s49"><i>I</i></span><span class="s38"> </span><span class="s1">is constructed by uses-allocator construction with allocator alloc and</span><span class="s6"> std</span><span class="s8"> :: </span><span class="s6">forward</span><span class="s8">&lt;</span><span class="s6">Args</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s6">args</span><span class="s11">)</span><span class="s8">...</span><span class="s6"> .</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: index</span><span class="s11">()</span><span class="s1"> is I.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of </span><span class="s28">T</span><span class="s33"><i>I</i></span><span class="s37"><i>.</i></span></p>
<p class="p49"><span class="s50"><i><span class="Apple-tab-span">	</span></i></span><span class="s16"><i>Remarks</i>: </span><span class="s51">If Allocator’s default constructor and </span><span class="s29">T</span><span class="s47"><i>I</i></span><span class="s50"><i> </i></span><span class="s16">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p28"><span class="s48">t</span><span class="s15">emplate</span><span class="s8">&lt;</span><span class="s1">size_t I, , </span><span class="s15">class</span><span class="s1"> U,<span class="Apple-converted-space">  </span></span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> </span><span class="s6">basic_variant</span><span class="s11">(</span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">,<span class="Apple-converted-space">  </span>initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1"> il,<span class="Apple-converted-space">  </span>Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s28"><i>Constraints</i>:</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- I is less than </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s28"> and</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s33"><i>I</i></span><span class="s28">, initializer_list</span><span class="s35">&lt;</span><span class="s28">U</span><span class="s35">&gt;&amp;</span><span class="s28">, Args</span><span class="s35">...&gt;</span><span class="s28"> is </span><span class="s41">true</span><span class="s28">.</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span>An alternative of type T</span><span class="s33"><i>I</i></span><span class="s28"> is constructed by uses-allocator construction with allocator alloc and il, std :: forward&lt;Args&gt;(args)... .</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><i>Postconditions</i>: index</span><span class="s42">()</span><span class="s28"> is I.</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T</span><span class="s33"><i>I</i></span><span class="s37"><i>.</i></span></p>
<p class="p49"><span class="s50"><i><span class="Apple-tab-span">	</span></i></span><span class="s29"><i>Remarks</i>: If Allocator’s default constructor and T</span><span class="s47"><i>I</i></span><span class="s50"><i> </i></span><span class="s29">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p30"><span class="s15">constexpr</span><span class="s6"> basic_variant</span><span class="s11">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p30"><span class="s15">constexpr</span><span class="s6"> basic_variant</span><span class="s11">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, </span><span class="s15">const</span><span class="s6"> basic_variant</span><span class="s8">&amp;</span><span class="s6"> w</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p30"><span class="s15">constexpr</span><span class="s6"> </span><span class="s1">basic_variant</span><span class="s11">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, basic_variant</span><span class="s8">&amp;&amp;</span><span class="s6"> w</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p30"><span class="s1">template&lt;class T&gt; constexpr basic_variant(allocator_arg_t, const Allocator&amp; a, T&amp;&amp; t);</span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const Allocator&amp; a, </span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s6"> U, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const Allocator&amp; a, </span><span class="s1">in_place_type_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1"> il, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s48">t</span><span class="s15">emplate</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">explicit</span><span class="s1"> basic_variant</span><span class="s11">(</span><span class="s6">allocator_arg_t, const Allocator&amp; a, </span><span class="s1">in_place_index_t</span><span class="s8">&lt;</span><span class="s1">I</span><span class="s8">&gt;</span><span class="s1">, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p30"><span class="s52">t</span><span class="s1">emplate&lt;size_t I, , class U,<span class="Apple-converted-space">  </span>class... Args&gt;<span class="Apple-converted-space"> </span></span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">  </span>constexpr explicit basic_variant(allocator_arg_t, const Allocator&amp; a, in_place_index_t&lt;I&gt;,<span class="Apple-converted-space">  </span>initializer_list&lt;U&gt; il,<span class="Apple-converted-space">  </span>Args&amp;&amp;... args);</span></p>
<p class="p63"><span class="s16"><span class="Apple-tab-span">	</span><i>Effects</i>: Behaves the same as non allocator extended version of the constructor except it initializes alloc with the specified allocator before initializing the alternative, if any, by uses-allocator construction.</span></p>
<p class="p18"><span class="s1"><br>
[Question to LWG : do we need to specify how triviality differs for these constructors?]<span class="Apple-converted-space"> </span></span></p>
<p class="p19"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s10"><b>x.x.x.x</b></span><span class="s28"><b> Destructor </b></span><span class="s1">[variant.basic.dtor]</span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; background-color: #21ff06"><span class="s15">constexpr</span><span class="s6"> </span><span class="s8">~ </span><span class="s1">basic_variant</span><span class="s11">()</span><span class="s6">;</span></h4>
<p class="p51"><span class="s1"><i>Effects</i>: If valueless_by_exception</span><span class="s11">()</span><span class="s1"> is </span><span class="s19">false</span><span class="s1">, destroys the currently contained value.</span></p>
<p class="p49"><span class="s16"><i>Remarks</i>: If is_trivially_destructible_v</span><span class="s18">&lt;</span><span class="s29">T</span><span class="s47"><i>i</i></span><span class="s18">&gt;</span><span class="s16"> is </span><span class="s53">true</span><span class="s16"> for all </span><span class="s29">T</span><span class="s47"><i>i</i></span><span class="s16">, then this destructor is trivial.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p66"><span class="s54"><b>x.x.x.x</b></span><span class="s29"><b> Assignment </b></span><span class="s16">[variant.basic.assign]</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p30"><span class="s15">constexpr</span><span class="s6"> </span><span class="s1">basic_variant</span><span class="s8">&amp;</span><span class="s6"> </span><span class="s15">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s15">const</span><span class="s6"> </span><span class="s1">basic_variant</span><span class="s8">&amp;</span><span class="s6"> rhs</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s28"><i>j</i></span><span class="s1"> be rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">().</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits&lt;Allocator&gt;::</span><span class="s28">propagate_on_container_copy_assignment::value is </span><span class="s41">true, sets alloc to rhs.alloc</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If neither </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> nor rhs holds a value, there is no additional effect.</span><span class="s36"><br>
</span><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> holds a value but rhs does not, destroys the value contained in </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> and sets </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> to not hold a value</span><span class="s36"><br>
</span><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> </span><span class="s28"><i>j</i></span><span class="s1">, assigns the value contained in rhs to the value contained in </span><span class="s8">*</span><span class="s15">this</span><span class="s1">,</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if<span class="Apple-converted-space"> </span></span></p>
<p class="p57"><span class="s38"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s6">uses_allocator_v&lt;</span><span class="s1">remove_cv_t&lt;</span><span class="s6">Tj&gt;&gt;, Allocator&gt; is false or </span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true</span><span class="s6">, and<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s28"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- either is_nothrow_copy_constructible_v</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s35">&gt;</span><span class="s28"> is </span><span class="s41">true</span><span class="s28"> or is_nothrow_move_constructible_v</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s35">&gt;</span><span class="s28"> is </span><span class="s41">false,</span></p>
<p class="p51"><span class="s14"><span class="Apple-converted-space">                           </span></span><span class="s1">destroys the current alternative, if any, and direct-non-list-initializes the contained value of type </span><span class="s38">T</span><span class="s49">j</span><span class="s37"> </span><span class="s1">with GET</span><span class="s8">&lt;</span><span class="s28">j</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">rhs</span><span class="s11">))</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to </span><span class="s15">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s1">basic_variant</span><span class="s11">(</span><span class="s1">allocator_arg, alloc, rhs</span><span class="s11">))</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i>Postconditions</i>: index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span></p>
<p class="p51"><span class="s1"><i>Returns</i>: </span><span class="s8">*</span><span class="s15">this</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i>Remarks</i>: This operator is defined as deleted unless is_copy_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_copy_assignable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i><a href="https://eel.is/c++draft/variant#assign-5.sentence-1"><span class="s6">.</span></a></span><span class="s1"> The assignment operator is trivial if :</span></p>
<p class="p51"><span class="s1">-  is_trivially_copy_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_trivially_copy_assignable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>I,</i></span></p>
<p class="p51"><span class="s1">- </span><span class="s28"> is_trivially_copy_constructible_v</span><span class="s35">&lt;</span><span class="s38">Allocator</span><span class="s35">&gt;</span><span class="s28"> </span><span class="s35">&amp;&amp;</span><span class="s28"> is_trivially_copy_assignable_v</span><span class="s35">&lt;</span><span class="s38">Allocator</span><span class="s35">&gt;</span><span class="s28"> </span><span class="s35">&amp;&amp;</span><span class="s28"> is_trivially_destructible_v</span><span class="s35">&lt;</span><span class="s38">Allocator</span><span class="s35">&gt;</span><span class="s28"> is true, and</span></p>
<p class="p63"><span class="s53">- </span><span class="s16">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true</span></p>
<p class="p60"><span class="s1"></span><br></p>
<p class="p30"><span class="s15">constexpr</span><span class="s6"> </span><span class="s1">basic_variant</span><span class="s8">&amp;</span><span class="s6"> </span><span class="s15">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s1">basic_variant</span><span class="s8">&amp;&amp;</span><span class="s6"> rhs</span><span class="s11">)</span><span class="s6"> </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s28"><i>j</i></span><span class="s1"> be rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_move_assignable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i><a href="https://eel.is/c++draft/variant#assign-7.sentence-1"><span class="s6">.</span></a></span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span></p>
<p class="p51"><span class="s28"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, sets alloc to rhs.alloc</span><span class="s1"><br>
<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If neither </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> nor rhs holds a value, there is no effect.</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> holds a value but rhs does not, destroys the value contained in </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> and sets </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> to not hold a value.</span><span class="s36"><br>
</span><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> </span><span class="s28"><i>j</i></span><span class="s1">, assigns <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>j</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">std</span><span class="s8">::</span><span class="s1">move</span><span class="s11">(</span><span class="s1">rhs</span><span class="s11">))</span><span class="s1"> to the value contained in </span><span class="s8">*</span><span class="s15">this</span><span class="s1">.</span></p>
<p class="p57"><span class="s38"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise,<span class="Apple-converted-space"> </span></span><span class="s6"> if </span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, </span><span class="s6">destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s49">j</span><span class="s55"> </span><span class="s6">with GET</span><span class="s8">&lt;</span><span class="s6">j</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s6">std</span><span class="s8">::</span><span class="s6">move</span><span class="s11">(</span><span class="s6">rhs</span><span class="s11">)))</span><span class="s6">.</span></p>
<p class="p51"><span class="s38"><span class="Apple-converted-space">                      </span></span><span class="s28">- Otherwise equivalent to </span><span class="s1">emplace</span><span class="s8">&lt;</span><span class="s28"><i>j</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1"><i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>j</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">std</span><span class="s8">::</span><span class="s1">move</span><span class="s11">(</span><span class="s1">rhs</span><span class="s11">)))</span><span class="s1">.</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Returns</i>: </span><span class="s8">*</span><span class="s15">this</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Remarks</i>: If </span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_trivially_move_assignable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i></span><span class="s1">, and<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space">                                </span>-</span><span class="s28"> is_trivially_move_constructible_v&lt;Allocator&gt; &amp;&amp; is_trivially_move_assignable_v&lt;Allocator&gt; &amp;&amp; is_trivially_destructible_v&lt;Allocator&gt; is true</span></p>
<p class="p57"><span class="s38"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s38"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">this assignment operator is trivial<a href="https://eel.is/c++draft/variant#assign-10.sentence-1"><span class="s28">.</span></a> </span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The exception specification is equivalent to logical and operation of (</span><span class="s38">allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp; allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) and<span class="Apple-converted-space">  </span></span><span class="s1">is_nothrow_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_nothrow_move_assignable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to </span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s1">'s move construction (with </span><span class="s28"><i>j</i></span><span class="s1"> being rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">), the variant will hold no value.</span></p>
<p class="p49"><span class="s16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to </span><span class="s29">T</span><span class="s47"><i>j</i></span><span class="s16">'s move assignment, the state of the contained value is as defined by the exception safety guarantee of </span><span class="s29">T</span><span class="s47"><i>j</i></span><span class="s16">'s move assignment; index</span><span class="s20">()</span><span class="s16"> will be </span><span class="s29"><i>j</i></span><span class="s16">.</span></p>
<p class="p61"><span class="s1"></span><br></p>
<p class="p27"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">constexpr</span><span class="s6"> basic_variant</span><span class="s8">&amp;</span><span class="s6"> </span><span class="s1">operator</span><span class="s8">=</span><span class="s11">(</span><span class="s6">T</span><span class="s8">&amp;&amp;</span><span class="s6"> t</span><span class="s11">)</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s37"><i> </i></span><span class="s1">be a type that is determined as follows: build an imaginary function <i>FUN</i></span><span class="s11">(</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s11">)</span><span class="s1"> for each alternative type </span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s1"> for which </span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s1"> x</span><span class="s11">[]</span><span class="s1"> </span><span class="s8">=</span><span class="s1"> </span><span class="s11">{</span><span class="s1">std</span><span class="s8"> :: </span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">t</span><span class="s11">)}</span><span class="s1">; is well-formed for some invented variable x<a href="https://eel.is/c++draft/variant#assign-11.sentence-1"><span class="s28">.</span></a> The overload <i>FUN</i></span><span class="s11">(</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s11">)</span><span class="s1"> selected by overload resolution for the expression <i>FUN</i></span><span class="s11">(</span><span class="s1">std</span><span class="s8"> :: </span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1"> t</span><span class="s11">))</span><span class="s1"> defines the alternative </span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s1"> which is the type of the contained value after assignment.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s8">&lt;</span><span class="s1">remove_cvref_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s1">, variant</span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">false</span><span class="s1">,</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- is_assignable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s8">&amp;</span><span class="s1">, T</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s1">, T</span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">, and</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- the expression <i>FUN</i></span><span class="s11">(</span><span class="s1">std</span><span class="s8"> :: </span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">t</span><span class="s11">))</span><span class="s1"> (with <i>FUN</i> being the above-mentioned set of imaginary functions) is well-formed<a href="https://eel.is/c++draft/variant#assign-12.sentence-1"><span class="s28">.</span></a></span></p>
<p class="p28"><span class="s28"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s1">[<i>Note </i>:</span><span class="s40"> </span></p>
<p class="p67"><span class="s1"><span class="Apple-converted-space">                             </span></span><span class="s14">variant</span><span class="s56">&lt;</span><span class="s14">string, string</span><span class="s56">&gt;</span><span class="s14"> v;</span></p>
<ul class="ul1">
  <ul class="ul2">
    <ul class="ul2">
      <li class="li30"><span class="Apple-converted-space">                                    </span><span class="s6">v </span><span class="s8">=</span><span class="s6"> </span><span class="s19">"abc"</span><span class="s6">;</span></li>
    </ul>
  </ul>
  <li class="li28"><span class="s44"> <span class="Apple-converted-space">                    </span></span><span class="s1">is ill-formed, as both alternative types have an equally viable constructor for the argument<a href="https://eel.is/c++draft/variant#assign-12.3.sentence-2">.</a> — <i>end note</i>]</span></li>
</ul>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span><span class="s36"><br>
</span><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If </span><span class="s8">*</span><span class="s15">this</span><span class="s1"> holds a </span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s1">, assigns std</span><span class="s8"> :: </span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">t</span><span class="s11">)</span><span class="s1"> to the value contained in </span><span class="s8">*</span><span class="s15">this</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, </span><span class="s28">if<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s28"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- uses_allocator_v&lt;remove_cvref_t &lt;Tj&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and<span class="Apple-converted-space"> </span></span></p>
<p class="p51"><span class="s28"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- either is_nothrow_copy_constructible_v&lt;T</span><span class="s33"><i>j</i></span><span class="s28">&gt; is true or is_nothrow_move_constructible_v&lt;T</span><span class="s33"><i>j</i></span><span class="s28">&gt; is false</span><span class="s14">,</span></p>
<p class="p57"><span class="s12"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s38"> </span><span class="s1">destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s33">j</span><span class="s37"> </span><span class="s1">with std::forward&lt;T&gt;(t).</span></p>
<p class="p51"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to emplace</span><span class="s35">&lt;</span><span class="s28"><i>j</i></span><span class="s35">&gt;</span><span class="s42">(</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s42">(</span><span class="s28">std</span><span class="s35">::</span><span class="s28">forward</span><span class="s35">&lt;</span><span class="s28">T</span><span class="s35">&gt;</span><span class="s42">(</span><span class="s28">t</span><span class="s42">)))</span><span class="s28">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: holds_alternative</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s8">*</span><span class="s15">this</span><span class="s11">)</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">, with </span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s1"> selected by the imaginary function overload resolution described above<a href="https://eel.is/c++draft/variant#assign-14.sentence-1"><span class="s28">.</span></a></span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Returns</i>: </span><span class="s8">*</span><span class="s15">this<a href="https://eel.is/c++draft/variant#assign-15.sentence-1"><span class="s38">.</span></a></span></p>
<p class="p28"><span class="s28"><i><span class="Apple-tab-span">	</span>Remarks</i>: The exception specification is equivalent to:</span><span class="s1"> is_nothrow_assignable_v</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s57"><i>j</i></span><span class="s8">&amp;</span><span class="s1">, T</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_nothrow_constructible_v</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s57"><i>j</i></span><span class="s1">, T</span><span class="s8">&gt; &amp;&amp; (!uses_allocator_v&lt;</span><span class="s28">remove_cvref_t </span><span class="s8">&lt;Tj&gt;, Allocator&gt; || allocator_traits&lt;Allocator&gt;::is_always_equal::value</span><span class="s38">)</span></p>
<p class="p51"><span class="s36"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">If an exception is thrown during the assignment of std</span><span class="s8">::</span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">t</span><span class="s11">)</span><span class="s1"> to the value contained in </span><span class="s8">*</span><span class="s15">this</span><span class="s1">, the state of the contained value and t are as defined by the exception safety guarantee of the assignment expression; valueless_by_exception</span><span class="s11">()</span><span class="s1"> will be </span><span class="s19">false<a href="https://eel.is/c++draft/variant#assign-16.1.sentence-1"><span class="s38">.</span></a></span></p>
<p class="p49"><span class="s16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the initialization of the contained value, the variant object is permitted to not hold a value.</span></p>
<p class="p9"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9"><span class="s6"><b> </b></span><span class="s21"><b>Modifiers</b></span><span class="s16"><b> [variant.basic.mod]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> emplace</span><span class="s11">(</span><span class="s1">Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s8">&lt;</span><span class="s1">T, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">, and T occurs exactly once in Types.</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Equivalent to:</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s15">return</span><span class="s1"> emplace</span><span class="s8">&lt;</span><span class="s28"><i>I</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">std</span><span class="s8">::</span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">Args</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">args</span><span class="s11">)</span><span class="s8">...</span><span class="s11">)</span><span class="s1">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s14"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">where </span><span class="s28"><i>I</i></span><span class="s1"> is the zero-based index of T in Types.</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 13.0px"><span class="s1"></span><br></h4>
<p class="p27"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s6"> U, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> emplace</span><span class="s11">(</span><span class="s1">initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1"> il, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s8">&lt;</span><span class="s1">T, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;&amp;</span><span class="s1">, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">, and T occurs exactly once in Types.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Equivalent to:</span></p>
<p class="p28"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</span><span class="s1"> emplace</span><span class="s8">&lt;</span><span class="s28"><i>I</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">il, std</span><span class="s8">::</span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">Args</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">args</span><span class="s11">)</span><span class="s8">...</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>where </span><span class="s28"><i>I</i></span><span class="s1"> is the zero-based index of T in Types.</span></p>
<p class="p62"><span class="s28"></span><br></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, </span><span class="s6">basic_variant</span><span class="s8">&lt;Allocator, </span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span><span class="s1"> emplace</span><span class="s11">(</span><span class="s1">Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: </span><span class="s28">I &lt; </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>I</i></span><span class="s1">, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Destroys the currently contained value if valueless_by_exception</span><span class="s11">()</span><span class="s1"> is </span><span class="s19">false</span><span class="s1">. Constructs an alternative of type </span><span class="s28">T</span><span class="s33"><i>I</i></span><span class="s1"> </span><span class="s38">by uses-allocator construction with allocator alloc and </span><span class="s1">std</span><span class="s8">::</span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">Args</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">args</span><span class="s11">)</span><span class="s8">… </span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: index</span><span class="s11">()</span><span class="s1"> is I<a href="https://eel.is/c++draft/variant#mod-8.sentence-1"><span class="s28">.</span></a></span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown during the initialization of the contained value.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the initialization of the contained value, the variant is permitted to not hold a value.</span></p>
<p class="p61"><span class="s1"></span><br></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s1"> U, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Args</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, </span><span class="s6">basic_variant </span><span class="s8">&lt;Allocator, </span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>emplace</span><span class="s11">(</span><span class="s1">initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;</span><span class="s1"> il, Args</span><span class="s8">&amp;&amp;...</span><span class="s1"> args</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: </span><span class="s28">I &lt; </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Constraints</i>: is_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>I</i></span><span class="s1">, initializer_list</span><span class="s8">&lt;</span><span class="s1">U</span><span class="s8">&gt;&amp;</span><span class="s1">, Args</span><span class="s8">...&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Destroys the currently contained value if valueless_by_exception</span><span class="s11">()</span><span class="s1"> is </span><span class="s19">false</span><span class="s1">. </span><span class="s28">Constructs an alternative of type T</span><span class="s33"><i>I</i></span><span class="s28"> by uses-allocator construction with allocator alloc and</span><span class="s1"> il, std</span><span class="s8"> :: </span><span class="s1">forward</span><span class="s8">&lt;</span><span class="s1">Args</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">args</span><span class="s11">)</span><span class="s8">... .</span></p>
<p class="p51"><span class="s8"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Postconditions</i>: index</span><span class="s11">()</span><span class="s1"> is I.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown during the initialization of the contained value.</span></p>
<p class="p49"><span class="s16"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the initialization of the contained value, the variant is permitted to not hold a value.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p21"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9"><span class="s21"><b>Value status</b></span><span class="s16"><b> [variant.basic.status]</b></span></h4>
<p class="p61"><span class="s1"></span><br></p>
<p class="p28"><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> valueless_by_exception</span><span class="s11">()</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p51"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Returns </span><span class="s19">false</span><span class="s1"> if and only if the variant holds a value.</span></p>
<p class="p28"><span class="s28"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">[<i>Note </i></span><span class="s13"><i>1</i></span><span class="s1">:</span><span class="s40"> </span><span class="s1">It is possible for a basic_variant to hold no value if an exception is thrown during a type-changing assignment or emplacement<a href="https://eel.is/c++draft/variant#status-2.sentence-1">.</a> The latter means that even a basic_variant</span><span class="s8">&lt;</span><span class="s15">float</span><span class="s1">, </span><span class="s15">int</span><span class="s8">&gt;</span><span class="s1"> can become valueless_by_exception</span><span class="s11">()</span><span class="s1">, for instance by</span></p>
<p class="p27"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>struct</span><span class="s6"> S </span><span class="s11">{</span><span class="s6"> </span><span class="s1">operator</span><span class="s6"> </span><span class="s1">int</span><span class="s11">()</span><span class="s6"> </span><span class="s11">{</span><span class="s6"> </span><span class="s1">throw</span><span class="s6"> </span><span class="s19">42</span><span class="s6">; </span><span class="s11">}}</span><span class="s6">;</span></p>
<p class="p26"><span class="s6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>basic_variant </span><span class="s1">&lt;std::allocator&lt;char&gt;, </span><span class="s15">float</span><span class="s6">, </span><span class="s15">int</span><span class="s1">&gt;</span><span class="s6"> v</span><span class="s11">{</span><span class="s19">12.f</span><span class="s11">}</span><span class="s6">;</span></p>
<p class="p28"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>v</span><span class="s8">.</span><span class="s1">emplace</span><span class="s8">&lt;</span><span class="s19">1</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">S</span><span class="s11">())</span><span class="s1">;</span></p>
<p class="p18"><span class="s16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>— <i>end note</i>]</span></p>
<p class="p61"><span class="s1"></span><br></p>
<p class="p27"><span class="s1">constexpr</span><span class="s6"> size_t index</span><span class="s11">()</span><span class="s6"> </span><span class="s1">const</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s6">;</span></p>
<p class="p49"><span class="s58"><span class="Apple-tab-span">	</span></span><span class="s16"><i>Effects</i>: If valueless_by_exception</span><span class="s20">()</span><span class="s16"> is </span><span class="s53">true</span><span class="s16">, returns variant_npos<a href="https://eel.is/c++draft/variant#status-3.sentence-1"><span class="s28">.</span></a> Otherwise, returns the zero-based index of the alternative of the contained value.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s59"><b>Allocator </b></span><span class="s1"><b>[variant.basic.all]</b></span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s1">allocator_type get_allocator</span><span class="s11">()</span><span class="s1"> </span><span class="s15">const</span><span class="s1">;</span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s16"><i>Returns</i>: A copy of the Allocator that was passed to the object's constructor or, if that allocator has been replaced, a copy of the most recent replacement.</span></h3>
<p class="p21"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s6"><b>Swap</b></span><span class="s1"><b> [variant.basic.swap]</b></span></h4>
<p class="p27"><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">void</span><span class="s6"> swap</span><span class="s11">(</span><span class="s6">basic_variant</span><span class="s8">&amp;</span><span class="s6"> rhs</span><span class="s11">)</span><span class="s6"> </span><span class="s1">noexcept</span><span class="s11">(</span><span class="s6"><i>see below</i></span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: is_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><i><span class="Apple-tab-span">	</span>Preconditions</i>: Each </span><span class="s28">T</span><span class="s33"><i>i </i></span><span class="s1">meets the <i>Cpp17Swappable</i> requirements (<a href="https://eel.is/c++draft/swappable.requirements"><span class="s10">[swappable.requirements]</span></a>)</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>:  </span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits</span><span class="s8">&lt;</span><span class="s1">Allocator</span><span class="s8">&gt;::</span><span class="s1">propagate_on_container_swap</span><span class="s8">::</span><span class="s1">value is </span><span class="s19">true</span><span class="s1">, then </span><span class="s28">Allocator</span><span class="s1"> shall meet the <i>Cpp17Swappable</i> requirements and the allocators of *this and res shall also be exchanged by calling swap as described in <a href="https://eel.is/c++draft/swappable.requirements"><span class="s10">[swappable.requirements]</span></a><a href="https://eel.is/c++draft/container.reqmts#65.sentence-3"><span class="s28">.</span></a> Otherwise, the allocators shall not be swapped, and the behavior is undefined unless *this</span><span class="s8">.</span><span class="s1">get_allocator</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> rhs</span><span class="s8">.</span><span class="s1">get_allocator</span><span class="s11">()</span><span class="s1">.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If valueless_by_exception</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> rhs</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1"> no additional effect.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, calls swap</span><span class="s11">(</span><span class="s1"><i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s8">*</span><span class="s15">this</span><span class="s11">)</span><span class="s1">, <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">rhs</span><span class="s11">))</span><span class="s1"> where </span><span class="s28"><i>i</i></span><span class="s1"> is index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, exchanges values of rhs and </span><span class="s8">*</span><span class="s15">this</span><span class="s1">.</span></p>
<p class="p51"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: If index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, any exception thrown by swap</span><span class="s11">(</span><span class="s1"><i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s8">*</span><span class="s15">this</span><span class="s11">)</span><span class="s1">, <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">rhs</span><span class="s11">))</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being index</span><span class="s11">()<a href="https://eel.is/c++draft/variant#swap-4.sentence-1"><span class="s38">.</span></a></span><span class="s1"> Otherwise, any exception thrown by the move constructor of </span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s1"> or </span><span class="s28">T</span><span class="s33"><i>j</i></span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being index</span><span class="s11">()</span><span class="s1"> and </span><span class="s28"><i>j</i></span><span class="s1"> being rhs</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p49"><span class="s16"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the call to function swap</span><span class="s20">(</span><span class="s16"><i>GET</i></span><span class="s18">&lt;</span><span class="s29"><i>i</i></span><span class="s18">&gt;</span><span class="s20">(</span><span class="s18">*</span><span class="s17">this</span><span class="s20">)</span><span class="s16">, <i>GET</i></span><span class="s18">&lt;</span><span class="s29"><i>i</i></span><span class="s18">&gt;</span><span class="s20">(</span><span class="s16">rhs</span><span class="s20">))</span><span class="s16">, the states of the contained values of </span><span class="s18">*</span><span class="s17">this</span><span class="s16"> and of rhs are determined by the exception safety guarantee of swap for lvalues of </span><span class="s29">T</span><span class="s47"><i>i</i></span><span class="s16"> with </span><span class="s29"><i>i</i></span><span class="s16"> being index</span><span class="s20">()<a href="https://eel.is/c++draft/variant#swap-5.sentence-1"><span class="s38">.</span></a></span><span class="s16"> If an exception is thrown during the exchange of the values of </span><span class="s18">*</span><span class="s17">this</span><span class="s16"> and rhs, the states of the values of </span><span class="s18">*</span><span class="s17">this</span><span class="s16"> and of rhs are determined by the exception safety guarantee of variant's move constructor<a href="https://eel.is/c++draft/variant#swap-5.sentence-2"><span class="s28">.</span></a> The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s18">&lt;</span><span class="s29">T</span><span class="s47"><i>i</i></span><span class="s18">&gt;</span><span class="s16"> </span><span class="s18">&amp;&amp;</span><span class="s16"> is_nothrow_swappable_v</span><span class="s18">&lt;</span><span class="s29">T</span><span class="s47"><i>i</i></span><span class="s18">&gt;</span><span class="s16"> for all </span><span class="s29"><i>i</i></span><span class="s16">.</span></p>
<p class="p73"><span class="s1"></span><br></p>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s60"><b>Add to </b><a href="https://eel.is/c++draft/variant#helper"><span class="s61"><b>22.6.4</b></span></a></span><span class="s1"><b> variant helper classes</b></span></h3>
<p class="p75"><span class="s1">template</span><span class="s62">&lt;</span><span class="s1">class</span><span class="s62">...</span><span class="s25"> Types</span><span class="s62">&gt;</span></p>
<p class="p76"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s63">struct</span><span class="s1"> variant_size</span><span class="s62">&lt;</span><span class="s1">variant</span><span class="s62">&lt;</span><span class="s1">Types</span><span class="s62">...&gt;&gt;</span><span class="s1"> </span><span class="s62">:</span><span class="s1"> integral_constant</span><span class="s62">&lt;</span><span class="s1">size_t, </span><span class="s63">sizeof</span><span class="s62">...</span><span class="s64">(</span><span class="s1">Types</span><span class="s64">)</span><span class="s62">&gt;</span><span class="s1"> </span><span class="s64">{</span><span class="s1"> </span><span class="s64">}</span><span class="s1">;</span></p>
<p class="p26"><span class="s15">template</span><span class="s1">&lt;class Allocator,<span class="Apple-converted-space">  </span></span><span class="s15">class</span><span class="s1">...</span><span class="s6"> Types</span><span class="s1">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">struct</span><span class="s1"> variant_size</span><span class="s8">&lt;basic_</span><span class="s1">variant</span><span class="s8">&lt;Allocator, </span><span class="s1">Types</span><span class="s8">...&gt;&gt;</span><span class="s1"> </span><span class="s8">:</span><span class="s1"> integral_constant</span><span class="s8">&lt;</span><span class="s1">size_t, </span><span class="s15">sizeof</span><span class="s8">...</span><span class="s11">(</span><span class="s1">Types</span><span class="s11">)</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s11">}</span><span class="s1">;</span></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p77"><span class="s1">…</span></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p76"><span class="s1">variant_alternative</span><span class="s62">&lt;</span><span class="s1">I, variant</span><span class="s62">&lt;</span><span class="s1">Types</span><span class="s62">...&gt;&gt;::</span><span class="s1">type</span></p>
<p class="p28"><span class="s1">variant_alternative</span><span class="s8">&lt;</span><span class="s1">I, basic_variant</span><span class="s8">&lt;Allocator, </span><span class="s1">Types</span><span class="s8">...&gt;&gt;::</span><span class="s1">type</span></p>
<p class="p78"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s28"><i>Mandates</i>: </span><span class="s1">I &lt; </span><span class="s15">sizeof</span><span class="s8">...</span><span class="s11">(</span><span class="s1">Types</span><span class="s11">)</span><span class="s28">.</span></p>
<p class="p49"><span class="s65"><span class="Apple-tab-span">	</span><i>Type</i>: The type </span><span class="s66">T</span><span class="s67"><i>I</i></span><span class="s68"><i>.</i></span></p>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s60"><b>Add to </b><a href="https://eel.is/c++draft/variant#get"><span class="s61"><b>22.6.5</b></span></a></span><span class="s1"><b> Value access</b></span></h3>
<p class="p79"><span class="s1"></span><br></p>
<p class="p24"><span class="s69">t</span><span class="s1">emplate</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> holds_alternative</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p30"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s6"> T, </span><span class="s1">class Allocator,<span class="Apple-converted-space">  </span></span><span class="s15">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> holds_alternative</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant</span><span class="s18">&lt;Allocator, </span><span class="s16">Types</span><span class="s18">...&gt;&amp;</span><span class="s16"> v</span><span class="s20">)</span><span class="s16"> </span><span class="s17">noexcept</span><span class="s16">;</span></p>
<p class="p49"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p49"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: </span><span class="s19">true</span><span class="s1"> if index</span><span class="s11">()</span><span class="s1"> is equal to the zero-based index of T in Types</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                                  </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;&amp;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                                </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                            </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;&amp;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                          </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p30"><span class="s15">template</span><span class="s8">&lt;</span><span class="s6">size_t I, </span><span class="s1">class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                                  </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">; <span class="Apple-converted-space">                                </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;<span class="Apple-converted-space">                            </span></span><span class="s9"><i>// exposition only</i></span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;&amp;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">&amp;&amp;</span><span class="s16"> v</span><span class="s20">)</span><span class="s16">; <span class="Apple-converted-space">                          </span></span><span class="s22"><i>// exposition only</i></span></p>
<p class="p19"><span class="s1"></span><br></p>
<p class="p49"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: </span><span class="s28">I &lt; </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i><span class="Apple-tab-span">	</span>Preconditions</i>: v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> is I.</span></p>
<p class="p49"><span class="s1"><i><span class="Apple-tab-span">	</span>Returns</i>: A reference to the object stored in </span><span class="s70">the variant</span><span class="s65"> </span><span class="s16">v</span><span class="s65">.</span></p>
<p class="p80"><span class="s1">.</span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p81"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p30"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p30"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p30"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">const</span><span class="s16"> variant_alternative_t</span><span class="s18">&lt;</span><span class="s16">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">&gt;&amp;&amp;</span><span class="s16"> get</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">&amp;&amp;</span><span class="s16"> v</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p21"><span class="s1"><i></i></span><br></p>
<p class="p49"><span class="s1"><i>Mandates</i>: </span><span class="s28">I &lt; </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Effects</i>: If v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> is I, returns a reference to the object stored in the </span><span class="s70">variant</span><span class="s1"> </span><span class="s16">v</span><span class="s1">. Otherwise, throws an exception of type bad_variant_access.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p18"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p18"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">const</span><span class="s6"> T</span><span class="s8">&amp;</span><span class="s6"> get</span><span class="s11">(</span><span class="s1">const</span><span class="s6"> variant</span><span class="s8">&lt;</span><span class="s6">Types</span><span class="s8">...&gt;&amp;</span><span class="s6"> v</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p24"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">constexpr</span><span class="s6"> </span><span class="s1">const</span><span class="s6"> T</span><span class="s8">&amp;&amp;</span><span class="s6"> get</span><span class="s11">(</span><span class="s1">const</span><span class="s6"> variant</span><span class="s8">&lt;</span><span class="s6">Types</span><span class="s8">...&gt;&amp;&amp;</span><span class="s6"> v</span><span class="s11">)</span><span class="s6">;</span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, </span><span class="s6">class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span><span class="s15">constexpr</span><span class="s1"> T</span><span class="s8">&amp;&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span><span class="s1"> </span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&amp;</span><span class="s1"> get</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&amp;</span><span class="s1"> v</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p18"><span class="s17">template</span><span class="s18">&lt;</span><span class="s17">class</span><span class="s16"> T, class Allocator, </span><span class="s17">class</span><span class="s18">...</span><span class="s16"> Types</span><span class="s18">&gt;</span><span class="s16"> </span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">const</span><span class="s16"> T</span><span class="s18">&amp;&amp;</span><span class="s16"> get</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">&amp;&amp;</span><span class="s16"> v</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p49"><span class="s1"><i>Effects</i>: If v holds a value of type T, returns a reference to that value<a href="https://eel.is/c++draft/variant#get-9.sentence-1"><span class="s28">.</span></a> Otherwise, throws an exception of type bad_variant_access.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p11"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">size_t I, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&gt;&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p30"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">*</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p30"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> variant_alternative_t</span><span class="s8">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">&gt;&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span>get_if</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">*</span><span class="s16"> v</span><span class="s20">)</span><span class="s16"> </span><span class="s17">noexcept</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: </span><span class="s28">I &lt; </span><span class="s43">sizeof</span><span class="s35">...</span><span class="s42">(</span><span class="s28">Types</span><span class="s42">)</span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: A pointer to the value stored in </span><span class="s70">the variant</span><span class="s1"> </span><span class="s16">v</span><span class="s1">, if v </span><span class="s8">!=</span><span class="s1"> </span><span class="s19">nullptr</span><span class="s1"> and v</span><span class="s8">-&gt;</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> I<a href="https://eel.is/c++draft/variant#get-11.sentence-1"><span class="s28">.</span></a> Otherwise, returns </span><span class="s19">nullptr<a href="https://eel.is/c++draft/variant#get-11.sentence-2"><span class="s38">.</span></a></span></p>
<p class="p61"><span class="s1"></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s6"> T, </span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;*</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s1">T</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s8">*</span><span class="s1"> v</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s1">;</span></p>
<p class="p28"><span class="s15">template</span><span class="s8">&lt;</span><span class="s15">class</span><span class="s1"> T, class Allocator, </span><span class="s15">class</span><span class="s8">...</span><span class="s1"> Types</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> add_pointer_t</span><span class="s8">&lt;</span><span class="s15">const</span><span class="s1"> T</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span>get_if</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s18">*</span><span class="s16"> v</span><span class="s20">)</span><span class="s16"> </span><span class="s17">noexcept</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p49"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s15">return</span><span class="s1"> get_if</span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1">; with </span><span class="s28"><i>i</i></span><span class="s1"> being the zero-based index of T in Types.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p83"><span class="s60"><b>Modify </b><a href="https://eel.is/c++draft/variant#relops"><span class="s61"><b>22.6.6</b></span></a></span><span class="s1"><b> Relational operators</b></span></p>
<p class="p84"><span class="s1"><b></b></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">==</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p30"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">class AllocatorV, class AllocatorW, </span><span class="s15">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> </span><span class="s17">operator</span><span class="s18">==</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s15">bool</span><span class="s1">, for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: If v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">!=</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">==</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">!=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s1">template&lt;class </span><span class="s6">AllocatorV</span><span class="s1">, </span><span class="s6">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> </span><span class="s17">operator</span><span class="s18">!=</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">!=</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s15">bool</span><span class="s1">, for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: If v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">!=</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">!=</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&lt;</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s1">template&lt;class </span><span class="s6">AllocatorV</span><span class="s1">, </span><span class="s6">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> </span><span class="s17">operator</span><span class="s18">&lt;</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s15">bool</span><span class="s1">, for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: If w</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise, if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&gt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&gt;</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s1">template&lt;class </span><span class="s6">AllocatorV</span><span class="s1">, </span><span class="s6">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> </span><span class="s17">operator</span><span class="s18">&gt;</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&gt;</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s15">bool</span><span class="s1">, for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: If v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise if w</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise, if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&gt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&gt;</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span></p>
<p class="p21"><span class="s1"><a href="https://eel.is/c++draft/variant#relops-8.sentence-1"></a></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&lt;=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s1">template&lt;class </span><span class="s6">AllocatorV</span><span class="s1">, </span><span class="s6">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> </span><span class="s17">operator</span><span class="s18">&lt;=</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&lt;=</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s15">bool</span><span class="s1">, for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: If v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if w</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise, if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&gt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&lt;=</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span></p>
<p class="p21"><span class="s1"><a href="https://eel.is/c++draft/variant#relops-10.sentence-1"></a></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">bool</span><span class="s1"> </span><span class="s15">operator</span><span class="s8">&gt;=</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s1">template&lt;class </span><span class="s6">AllocatorV</span><span class="s1">, </span><span class="s6">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s16"> </span><span class="s17">bool</span><span class="s16"> </span><span class="s17">operator</span><span class="s18">&gt;=</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&gt;=</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s15">bool</span><span class="s1">, for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i>Returns</i>: If w</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise, if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&gt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">true</span><span class="s1">; otherwise if v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&lt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">, </span><span class="s19">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&gt;=</span><span class="s1"> <i>GET</i></span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1"> with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s1">requires</span><span class="s6"> </span><span class="s11">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s13">three_way_comparable</span></a></span><span class="s8">&lt;</span><span class="s6">Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s8">&amp;&amp;</span><span class="s6"> </span><span class="s8">...</span><span class="s11">)</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s8">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">&gt;...&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s15">operator</span><span class="s8">&lt;=&gt;</span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, </span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p27"><span class="s1">template&lt;class </span><span class="s6">AllocatorV</span><span class="s1">, </span><span class="s6">class AllocatorW, </span><span class="s1">class... Types&gt;</span><span class="s6"> </span><span class="s1">requires</span><span class="s6"> </span><span class="s11">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s13">three_way_comparable</span></a></span><span class="s8">&lt;</span><span class="s6">Types</span><span class="s8">&gt;</span><span class="s6"> </span><span class="s8">&amp;&amp;</span><span class="s6"> </span><span class="s8">...</span><span class="s11">)</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s8">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">&gt;...&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space">    </span></span><span class="s17">operator</span><span class="s18">&lt;=&gt;</span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorV</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> v, </span><span class="s17">const</span><span class="s16"> basic_variant&lt;</span><span class="s21">AllocatorW</span><span class="s16">, Types...&gt;</span><span class="s18">&amp;</span><span class="s16"> w</span><span class="s20">)</span><span class="s16">;</span></p>
<p class="p49"><span class="s14"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s11">(</span><span class="s1">v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">())</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">return</span><span class="s1"> strong_ordering</span><span class="s8">::</span><span class="s1">equal;</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s11">(</span><span class="s1">v</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">())</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> strong_ordering</span><span class="s8">::</span><span class="s1">less;</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s11">(</span><span class="s1">w</span><span class="s8">.</span><span class="s1">valueless_by_exception</span><span class="s11">())</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> strong_ordering</span><span class="s8">::</span><span class="s1">greater;</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s11">(</span><span class="s15">auto</span><span class="s1"> c </span><span class="s8">=</span><span class="s1"> v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1"> </span><span class="s8">&lt;=&gt;</span><span class="s1"> w</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">; c </span><span class="s8">!=</span><span class="s1"> </span><span class="s19">0</span><span class="s11">)</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> c;</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</span><span class="s1"> \exposid</span><span class="s11">{</span><span class="s1">GET</span><span class="s11">}</span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">v</span><span class="s11">)</span><span class="s1"> </span><span class="s8">&lt;=&gt;</span><span class="s1"> \exposid</span><span class="s11">{</span><span class="s1">GET</span><span class="s11">}</span><span class="s8">&lt;</span><span class="s28"><i>i</i></span><span class="s8">&gt;</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p49"><span class="s1"><span class="Apple-tab-span">	</span>with </span><span class="s28"><i>i</i></span><span class="s1"> being v</span><span class="s8">.</span><span class="s1">index</span><span class="s11">()</span><span class="s1">.</span></p>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s60"><b>Modify </b><a href="https://eel.is/c++draft/variant#visit"><span class="s61"><b>22.6.7</b></span></a></span><span class="s1"><b> Visitation</b></span></h3>
<p class="p49"><span class="s1">Let <i>as-variant</i> denote the following exposition-only function templates:</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Ts</span><span class="s8">...&gt;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> var; </span><span class="s11">}</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Ts</span><span class="s8">...&gt;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> var; </span><span class="s11">}</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Ts</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> std</span><span class="s8">::</span><span class="s1">move</span><span class="s11">(</span><span class="s1">var</span><span class="s11">)</span><span class="s1">; </span><span class="s11">}</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s11">(</span><span class="s15">const</span><span class="s1"> variant</span><span class="s8">&lt;</span><span class="s1">Ts</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> std</span><span class="s8">::</span><span class="s1">move</span><span class="s11">(</span><span class="s1">var</span><span class="s11">)</span><span class="s1">; </span><span class="s11">}</span></p>
<p class="p27"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Ts</span><span class="s8">...&gt;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> var; </span><span class="s11">}</span></p>
<p class="p27"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant (</i></span><span class="s15">const</span><span class="s1"> basic_variant&lt;Allocator, Ts</span><span class="s8">...&gt;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> var; </span><span class="s11">}</span></p>
<p class="p27"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s15">auto</span><span class="s8">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s11">(</span><span class="s1">basic_variant&lt;Allocator, Ts</span><span class="s8">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s11">)</span><span class="s1"> </span><span class="s11">{</span><span class="s1"> </span><span class="s15">return</span><span class="s1"> std</span><span class="s8">::</span><span class="s1">move</span><span class="s11">(</span><span class="s1">var</span><span class="s11">)</span><span class="s1">; </span><span class="s11">}</span></p>
<p class="p27"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s8">...</span><span class="s6"> Ts</span><span class="s8">&gt;</span></p>
<p class="p18"><span class="s16"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> </span></span><span class="s17">auto</span><span class="s18">&amp;&amp;</span><span class="s16"> <i>as-variant</i></span><span class="s20">(</span><span class="s17">const</span><span class="s16"> basic_variant&lt;Allocator, Ts</span><span class="s18">...&gt;&amp;&amp;</span><span class="s16"> var</span><span class="s20">)</span><span class="s16"> </span><span class="s20">{</span><span class="s16"> </span><span class="s17">return</span><span class="s16"> std</span><span class="s18">::</span><span class="s16">move</span><span class="s20">(</span><span class="s16">var</span><span class="s20">)</span><span class="s16">; </span><span class="s20">}</span></p>
<p class="p21"><span class="s1"></span><br></p>
<p class="p49"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s28"><i>n</i></span><span class="s1"> be </span><span class="s15">sizeof</span><span class="s8">...</span><span class="s11">(</span><span class="s1">Variants</span><span class="s11">)</span><span class="s1">…</span></p>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #000000; -webkit-text-stroke: #0000e9; min-height: 19.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s60"><b>Modify </b><a href="https://eel.is/c++draft/variant#specalg"><span class="s61"><b>22.6.10</b></span></a></span><span class="s1"><b> Specialized algorithms</b></span></h3>
<p class="p82"><span class="s1">template</span><span class="s8">&lt;</span><span class="s1">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<p class="p11"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s15">constexpr</span><span class="s1"> </span><span class="s15">void</span><span class="s1"> swap</span><span class="s11">(</span><span class="s1">variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> v, variant</span><span class="s8">&lt;</span><span class="s1">Types</span><span class="s8">...&gt;&amp;</span><span class="s1"> w</span><span class="s11">)</span><span class="s1"> </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s1"><i>see below</i></span><span class="s11">)</span><span class="s1">;</span></p>
<p class="p81"><span class="s15">template</span><span class="s8">&lt;</span><span class="s1">class Allocator,<span class="Apple-converted-space">  </span></span><span class="s15">class</span><span class="s8">...</span><span class="s6"> Types</span><span class="s8">&gt;</span></p>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #440045"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s17">constexpr</span><span class="s21"> </span><span class="s17">void</span><span class="s21"> swap</span><span class="s20">(</span><span class="s16">basic_</span><span class="s21">variant</span><span class="s16">&lt;Allocator, </span><span class="s21">Types</span><span class="s16">...&gt;&amp;</span><span class="s21"> v, </span><span class="s16">basic_</span><span class="s21">variant</span><span class="s16">&lt;Allocator, </span><span class="s21">Types</span><span class="s16">...&gt;&amp;</span><span class="s21"> w</span><span class="s20">)</span><span class="s21"> </span><span class="s17">noexcept</span><span class="s20">(</span><span class="s21"><i>see below</i></span><span class="s20">)</span><span class="s21">;</span></h3>
<p class="p49"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> </span><span class="s8">&amp;&amp;</span><span class="s1"> is_swappable_v</span><span class="s8">&lt;</span><span class="s28">T</span><span class="s33"><i>i</i></span><span class="s8">&gt;</span><span class="s1"> is </span><span class="s19">true</span><span class="s1"> for all </span><span class="s28"><i>i</i></span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: Equivalent to v</span><span class="s8">.</span><span class="s1">swap</span><span class="s11">(</span><span class="s1">w</span><span class="s11">)</span><span class="s1">.</span></p>
<p class="p49"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: The exception specification is equivalent to </span><span class="s15">noexcept</span><span class="s11">(</span><span class="s1">v</span><span class="s8">.</span><span class="s1">swap</span><span class="s11">(</span><span class="s1">w</span><span class="s11">))<a href="https://eel.is/c++draft/variant#specalg-3.sentence-1"><span class="s38">.</span></a></span></p>
<p class="p21"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s60"><b>Modify </b><a href="https://eel.is/c++draft/variant#hash"><span class="s61"><b>22.6.12</b></span></a></span><span class="s1"><b> Hash support</b></span></h3>
<p class="p86"><span class="s1"></span><br></p>
<p class="p87"><span class="s15">template</span><span class="s1">&lt;</span><span class="s15">class</span><span class="s6"> Allocator, </span><span class="s15">class</span><span class="s1">...</span><span class="s6"> Types</span><span class="s1">&gt;</span><span class="s6"> </span><span class="s15">struct</span><span class="s6"> hash</span><span class="s1">&lt;basic_</span><span class="s6">variant</span><span class="s1">&lt;Allocator, </span><span class="s6">Types</span><span class="s1">...&gt;&gt;</span><span class="s6">;</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s16">The specialization hash</span><span class="s18">&lt;basic_</span><span class="s16">variant</span><span class="s18">&lt;</span><span class="s71">Allocator , </span><span class="s16">Types</span><span class="s18">...&gt;&gt;</span><span class="s16"> is enabled (<a href="https://eel.is/c++draft/unord.hash"><span class="s10">[unord.hash]</span></a>) if and only if every specialization in hash</span><span class="s18">&lt;</span><span class="s16">remove_const_t</span><span class="s18">&lt;</span><span class="s16">Types</span><span class="s18">&gt;&gt;...</span><span class="s16"> is enabled<a href="https://eel.is/c++draft/variant#hash-1.sentence-1"><span class="s28">.</span></a> The member functions are not guaranteed to be </span><span class="s17">noexcept</span><span class="s16">.</span></h3>
<p class="p21"><span class="s1"></span><br></p>
<p class="p9"><span class="s1"></span><br></p>
</body>
</html>
