---
title: "Policies for Using Allocators in Library Classes"
document: D3002R1
date: <!-- $TimeStamp$ -->2024-02-12 15:43 EST<!-- $ -->
audience: LEWG
author:
  - name: Pablo Halpern
    email: <phalpern@halpernwightsoftware.com>
working-draft: N4971
---

Abstract
========

To ensure consistency and cut down on excessive debate, LEWG is in the process
of creating a standing document, SD-9, of design policies to be followed by
default when proposing new facilities for the Standard Library; exceptions to
these policies would require paper author to provide rationale for each
exception.  Because the Standard Library should give users control over the
source of memory used by Library objects, policies on when and how classes
should accept an allocator are badly needed so that allocator support does not
become an afterthought or a topic of endless debate.  This paper propose a
policy regarding when library classes should have an allocator parameter.

Change Log
==========

R1: Added additional motivation and information to meet the requirements
specified in [@P2267R1].

R0: Initial version.

Motivation/Rationale
====================

Memory management is a major part of building software. Numerous facilities in
the C++ Standard library exist to give the programmer maximum control over how
their program uses memory:

* `std::unique_ptr` and `std::shared_ptr` are parameterized with *deleter*
  objects that control, among other things, how memory resources are reclaimed.

* `std::vector` is preferred over other containers in many cases because its
  use of contiguous memory provides optimal cache locality and minimizes
  allocate/deallocate operations.

* Operators `new` and `delete` are replaceable, giving programmers global
  control over how memory is allocated.

* The C++ object model makes a clear distinction between an object's memory
  footprint and it's lifetime.

* Language constructs such as `void*` and `reinterpet_cast` provide
  fine-grained access to the objects' underlying memory.

* Standard containers and strings are parameterized with allocators, providing
  local control over how they allocate memory and construct subobjects.

The fine-grained control over memory that C++ gives the programmer is a large
part of why C++ is applicable to so many domains --- from embedded systems with
limited memory budgets to games, high-frequency trading, and scientific
simulations that require cache locality, thread affinity, and other
memory-related optimizations for optimal performance.

Standard containers are the most obvious examples of *allocator-aware*
types. Their characteristic allocator-parameterized constructors as well as
`allocator_type` and `get_allocator` members allow them to be used as LegoÂ®
parts that can be combined and nested as necessary while retaining full
programmer control over how they allocate memory. For scoped allocators (see
[Prior Art](#Prior Art in the Standard)), in particular, having each element of
an container support a predictable allocator-aware interface is critical to
giving the programmer the ability to allocate all memory from a single memory
resource, such as an arena or pool. Note that an allocator is a *configuration*
parameter to an object and does not contribute to its value.

An in-depth description of the value proposition for allocator-aware software
can be found in [@P2035R0].

In short, the principles behind this policy proposal are:

1. **The Standard Library should be general and flexible**. To the extent
   possible, the user of a library class should have control over how memory is
   allocated.

2. **The Standard Library should be consistent**. The use of allocators should
   be consistent with the existing allocator-aware classes and class templates,
   especially those in the containers library.

3. **The Standard Library should encapsulate complexity**.  Fully general
   application of allocators is potentially complex and is best left to the
   experts implementing the Standard Library.  Users can choose their own
   subset of desirable allocator behavior only if the underlying Library
   classes allow them to choose their preferred approach, whether it be
   stateless allocators, statically typed allocators, polymorphic allocators,
   or no allocators.

4. **The Standard Library should try to provide simplifications of complex
   facilities**. The PMR part of the standard library is intended to provide a
   simplified allocator model for a common use case -- that of providing an
   allocator to a class object and its subparts without infecting the object's
   type.


Prior Art in the Standard
=========================

Allocator Types
---------------

An allocator type is a class template having member functions `allocate` and
`deallocate` and, optionally, `construct` and `destroy`. Allocators can be
divided *stateless* and *stateful*, with stateful allocators subdivided into
*shallow* and *scoped* categories. The Standard Library defines two allocators,
`std::allocator`, which is stateless, and `std::pmr::polymorphic_allocator`,
which is scoped. It also defines `std::scoped_allocator_adaptor`, which makes
shallow allocators into scoped allocators. The requirements for allocator types
are described in [allocator.requirements]{.sref}.

The `allocator_traits` class template provides a uniform interface for all
allocator types, providing default operations and types for optional interface
elements (see [allocator.traits]{.sref}).

Polymorphic Allocators
----------------------

Classic allocators are provided as template parameters, with behavior
determined at compile time. This model does not always scale, as clients of an
allocator-aware type might also need to be templates in order to take advantage
of the flexibility afforded by the allocator facility.

The `std::pmr::polymorphic_allocator` class template is scoped allocator that
acts as a bridge between the traditional statically selected allocator and a
runtime-selected allocator. The mechanism by which a `polymorphic_allocator`
manages memory is delegated to a *resource* object whose type is derived from
`std::pmr::memory_resource`. Two container objects using
`polymorphic_allocator` can have identical type yet allocate memory using
different mechanisms. Moreover, a user-defined type that is not a template can
use allocators in its interface and implementation without introducing template
complexity. At the cost of a virtual function dispatch for allocation and
deallocation, polymorphic allocators provide a simpler sub-model for many uses.
See the CppCon 2017 talk, [@Halpern2017], for more information about
polymorphic allocators and how they simplify allocator-aware development.

Allocator-aware Containers
--------------------------

Except for `array`, each container in the Standard Library supports an
allocator template parameter and each of its constructors has a version that
allows an allocator to be passed in at initialization. An allocator-aware
container has an `allocator_type` member type and a `get_allocator` member
function returning the allocator. The `Allocator` parameter for all
allocator-aware containers in the `std` namespace defaults to
`std::allocator`.

Allocator-aware containers are required, per [container.alloc.reqmts]{.sref},
to allocate memory and construct elements using the `allocate` and `construct`
members of `allocator_traits`. Whether a container's allocator is copied during
copy construction, copy assignment, move assignment, or swap is determined by
the allocator's *propagation traits*, which are also accessed via
`allocator_traits`.

Each allocator-aware container also has an alias for which the `allocator_type`
is `std::pmr::polymorphic_allocator` in the `std::pmr` namespace:

```cpp
namespace pmr {
  template <class T>
    class vector = std::vector<T, polymorphic_allocator<T>>;
}
```

The `pmr` alias simplifies the use of the polymorphic allocators sub-model by
creating a set of containers, having the same scoped allocator type, that can
be nested arbitrarily, i.e,

```cpp
std::pmr::monotonic_buffer_resource buff_rsrc;

// the_list and all of the strings within the_list will allocate memory from buff_rsrc.
std::pmr::list<std::pmr::string> the_list(&buff_rsrc);
```

Non-container Allocator Use
---------------------------

Allocators are used by `tuple`, `ranges::generator`, and `string_stream`,
`sync_stream`, regular expressions, and `promise`. `tuple` is an interesting
case because it does not, directly, allocate memory. Rather, `tuple`, might
contain elements that use allocators. The `tuple` constructors allow an
allocator to be passed to those elements. For example `tuple<pmr::string, int,
double>` can be constructed with an allocator that is passed to the first
element. When an allocator is passed to a `tuple` constructor, each element is
constructed by *uses-allocator construction*
([allocator.uses.construction]{.sref}). There is a special case of
*uses-allocator construction* for `std::pair` that allows an allocator to be
passed to the elements of a `pair`.


Survey of Allocator Use in the Wider C++ Community
==================================================

C++ allocators are used for a variety of purposes in various
industries. Although statistics are hard to come by, below are some industry
anecdotes.

* **Bloomberg (financial services)**: Bloomberg is probably the biggest
  proponent of allocator use in the community.  Most of Bloomberg's C++ code
  base is allocator-enabled and allocators are used for a variety of purposes:
  cache locality, thread affinity, thread safety, shared memory, bug detection,
  and a type of garbage collection called *winking out*. Winking out is the act
  of abandoning an object without invoking its destructor by summarily
  reclaiming all memory allocated by that object and its subobjects. Though
  intended as a tutorial for Bloomberg engineers, the general concepts in the
  first few sections of [@P2127R0] can be useful for WG21 members interested in
  how allocator-aware software is put together.

* **Intel (enabling software for Intel CPUs)**: Intel uses allocators to
  provide thread safety and thread affinity, as well as to allocate specific
  data structures in special-purpose memory pools such as high-bandwidth
  memory.

* **Cradle (music production software)**: Cradle used allocators to provide
  deterministic execution time for allocating from a fixed buffer. They use
  `pmr::polymorphic_allocator` with `pmr:: monotonic_buffer_resource` and
  `std::pmr::unsynchronized_pool_resource` chained together to achieve
  determimism with ease of use.

* **Nvidia (GPUs)**: Memory management for GPUs and for local memory on CPUs.
  They use a custom approach similar to `pmr` that it lets allocation be
  asynchronous with respect to a stream ("stream-ordered"). Mark Hoemmen said
  "The best part of this model is that users can control allocation behavior,
  without needing to think too much about it."

* **NI (computerized lab instrumentation)**: NI used an allocators in their
  kernel-mode drivers to provide page locked memory, and another allocator that
  provides pageable memory. Their use was not entirely standards conforming.

* **Multiple companies (Cyclic Graph)**: Graphs that have cycles create
  notoriously difficult memory-management problems. Using `shared_ptr` alone
  creates cycles that never get deallocated whereas using `weak_ptr` requires a
  separate registry holding all nodes. The entire graph can be managed,
  however, by allocating all of the nodes from a common pool- or arena-
  allocator, which reclaims all used memory at once when the graph is no longer
  needed. Note that this approach assumes that no resources besides memory are
  held by the nodes (because destructors are not called). This approach is a
  subset of the design described by Herb Sutter in his CppCon 2016 keynote,
  [@Sutter2016].


Summary of Proposed Policies
============================

The policies described in the [Proposed SD-9 Wording](#Proposed SD-9 Wording)
section, below, are intended to ensure that new classes that allocate memory,
directly or indirectly, are designed to enable the use of allocators to preform
that allocation. It would be ideal if some or all of the *allocator-aware
containers* requirements described in [container.alloc.reqmts]{.sref} were
hoisted to their own section of the standard, describing all allocator-aware
classes, not just containers. Such a change to the standard is outside the
scope of this policy proposal, but is worth considering for the future, as it
would make wording of these policies a bit simpler.

The most salient policy proposals are that:

* A class that might allocate per-object memory should be allocator aware.

* A class that contain members that might allocate per-object memory should
  accept an allocator on construction and pass the allocator to those members'
  constructors.

A partial exception is made for situations where the overhead caused by an
allocator parameter would be too great. Specifically, if the compile-time or
runtime overhead of using `X<T, Alloc = std::allocator<>>` is excessive, then
it might make sense to have a separate `basic_X<T, Alloc>` in addition to the
non-allocator-aware `X`. This approach is not encouraged, however, as it
creates more potential for the use incompatible types in a program and
increases the decision load on a programmer who must decide which of the two
types to use. Note that, as with all exceptions, it is incumbent on the author
of the proposal to justify exception.


Why Adopting these Policies would Improve Coherence and Save Time
=================================================================

Advantages
----------

* Having a consistent allocator-aware infrastructure allows the various types
  that allocate memory to work together as building blocks that give the
  programmer control over how memory is allocated and used.

* The LEWG has spent many hours debating, in person and on the reflector,
  whether this class or that should take an allocator. These policies should
  short-circuit most of those debates.

* There have been many instances in my memory where a type was proposed without
  allocators and needed to be reworked to enable allocator use. Having these
  policies in the *checklist* of LEWG policies should enable paper authors to
  come to the committee with higher-quality and more complete proposals.

Disadvantages
-------------

* Allocators make the class specification more complex.

* Allocators make implementation more difficult.

* The flexibility afforded by the C++11 allocator model increases compile time
  by introducing metaprogramming based on `allocator_traits` and propagation
  traits.

In considering the first two points, bear in mind that our main task is to make
C++ as useful as possible for programmers, not to make our job easier when
writing an interface specification or implementing the Standard Library
itself. Tutorials can and should simplify as necessary, deferring some
complexity for more advanced topics. Although constantly having to consider
allocators can be annoying, it is not much different from having to constantly
consider exceptions, yet discussions on removing exceptions from the library
are not usually centered on the tedium of specifying exceptional behavior in
the standard library.

The third issue can be largely mitigated by an implementations specializing a
class template that uses `std::allocator`.  Such a specialization need not use
`allocator_traits` or consider propagation traits at all, and so should be
almost as fast to compile (and run) as a non-allocator-aware class.


Proposed SD-9 Wording
=====================

Append to "List of Standard Library Policies" section of SD-9, the following
policies. Note that the policy numbers are relative --- policy #1 below is
really the first policy after the current last policy in the section.

1. A class that allocates memory should be *allocator-aware*, and should
   conform to as many of the *allocator-aware container* requirements (section
   [container.alloc.reqmts]{.sref}) as apply, where requirements on `T` are
   interpreted as requirements on any type potentially constructed within the
   allocated memory.

2. If it can be shown that applying the previous policy and making a class
   allocator-aware would incur excessive cost (in compile- and/or run-time),
   then the allocator-aware behavior can be separated out into a separate
   class, typically using the same name with the prefix, "`basic_`."

3. The default allocator type for an allocator-aware class when none is
   specified by the user should be a specialization of `std::allocator`.

4. For each allocator-aware class template, there should be an alias in the
   `std::pmr` namespace that uses a specialization of
   `std::pmr::polymorphic_allocator` instead of `std::allocator` as the
   allocator type. If the allocator-aware class name begins with `basic_`
   prefix, the `std::pmr` alias name should typically *not* have the prefix.

5. A class that may contain subobjects (base classes or members) that use
   allocators should accept an allocator, `A` at construction to forward it to
   those subobjects via *uses-allocator construction*with allocator `A`
   ([allocator.uses.construction]{.sref}).  If such a class, `X` does not
   define `allocator_type`, then `std::uses_allocator<X, Alloc>` should be
   specialized to derive from `true_type` for all acceptable allocator types,
   `Alloc` (see [allocator.uses.trait]{.sref}). Such a class is called
   *allocator-enabled*, but is not necessarily *allocator-aware*.

6. For the purpose at these allocator-related policies, a *fixed-sized* buffer
   in the object that is not allocated is treated as a member variable whereas
   a *dynamically sized* buffer is treated as allocated memory, even if it
   happens to fit within the object's footprint when below a certain size
   (i.e., the small-object optimization).

7. If a class is allocator-aware or allocator-enabled, then every constructor
   should have a variant (via overloading or default arguments) that takes an
   allocator. This quality enables *uses-allocator construction* in generic
   contexts (see [allocator.uses.construction]{.sref}).

---
references:
  - id: P2127R0
    citation-label: P2127R0
    author:
      - family: Halpern
        given: Pablo
    title: "Making C++ Software Allocator Aware"
    URL: http://wg21.link/P2127R0
  - id: Halpern2017
    citation-label: Halpern2017
    author:
      - family: Halpern
        given: Pablo
    title: "Allocators, The Good Parts"
    URL: https://youtu.be/v3dz-AKOVL8?si=mi5JOJMaqD6lvRqv
  - id: Sutter2016
    citation-label: Sutter2016
    author:
      - family: Sutter
        given: Herb
    title: "Leak-Freedom in C++... By Default"
    URL: https://youtu.be/JfmTagWcqoE?si=OZ7EeziRKPaDnHSx
---
