---
title: "Better lookups for `map` and `unordered_map`"
document: D3091R0
date: <!-- $TimeStamp$ -->2024-01-23 23:03 EST<!-- $ -->
audience: LEWGI
author:
  - name: Pablo Halpern
    email: <phalpern@halpernwightsoftware.com>

---

Abstract
========

> The most convenient way to look up an element of a `map` or `unordered_map`
> is to use the index operator, i.e., `theMap[key]`. This operator has a number
> of limitations, however: 1) it does not work for `const` containers, 2) it
> does not work if the mapped type is not default-constructible, 3) it modifies
> the container if the key is not found, 4) it can be inefficient for mapped
> types having expensive default constructors or expensive assignment
> operators, 5) a default-constructed value is not always the desired value
> when the key is not found. These limitations often require that the user
> resort to using the `find` member function, which returns an iterator and
> typically leads to more complex code having at least one `if` statement
> and/or duplicate lookup operations. This paper take inspiration from other
> languages, especially Python, and proposes three simple member functions
> (`get`, `get_ref`, and `replace`) that simplify lookups for `map` and
> `unordered_map` in situations where the index operator is suboptimal.

Motivation
==========

Just about every modern computer language has, as part of the language or its
standard library, one or more associative containers variously called `map`,
`hash_map`, `dictionary`, or something similar that uniquely associates a key
with a mapped value. In C++ we have `std::map`, `std::unordered_map`, and
eventually (per [@P0429R9] and [@P2767R2]) `std::flat_map`. The easy-to-write
and easy-to-read expression for getting a value for an associated key is
simply, `theMap[key]`C++, in other words, a mapped value is retrieved (and
often set) using the index operator, which returns a reference to the value
associated with the key. Unfortunately, the index operator in the C++
associative containers has a number of shortcomings compared to many other
languages:

* It works only for non-`const` containers.
* It works only for default-constructible mapped types
* The default-constructed object (when available) is not always the correct
  identity for a given use case.
* It modifies the container when the key is absent.

For example, consider a `std::map` named `theMap`, which maps an integer key to
a floating-point value, modeling a sparse array of `double`. If we want to find
the largest of the values mapped to the integer range 1 to 100, we might be
tempted to write the following loop:

```cpp
double largest = -std::numeric_limits<double>::infinity();
for (int i = 1; i <= 100; ++i)
  largest = std::max(largest, theMap[i]);
```

If `theMap` is `const`, the loop will not compile. If any of the keys in the
range [1, 100] are absent from the map, then its value is treated as `0.0`
default-constructed `double` has value 0.0; this behavior might or might not
be desirable, depending on whether we want to treat missing values as truly
having value 0.0 or whether they should be ignored (or, equivalently, treated
as having value `-inf`). Finally if, before executing this loop, `theMap`
contains only, say, five entries, at the end of the loop it will contain at
least 100 entries, most of which will have (unnecessary) zero values.

Of course, there are alternatives that avoid all of these shortcomings, but the
alternatives are significantly less elegant, syntactically, and therefore error
prone.  For example the `at` member function looks a lot like `operator[]` and
has none of the above shortcomings, but missing keys are handled by throwing
exceptions, making it impractical for situations other than when the key is
almost certain to exist; moreover, structuring the code with a `try`-`catch`
block is rarely a clean factoring of the problem:

```cpp
double largest = -std::numeric_limits<double>::infinity();
for (int i = 1; i <= 100; ++i)
{
  try {
    largest = std::max(largest, theMap.at(i));
  } catch (const std::out_of_range&) { }
}
```

The above code would work with a `const`, would ignore missing elements (rather
than treating them as zeros), and would populate the map with useless entries,
but many would argue that the loop is inelegant, at best. In most C++
implementations, it would be extremely inefficient unless key misses are rare.

The other obvious alternative is the `find` member function:

```cpp
double largest = -std::numeric_limits<double>::infinity();
for (int i = 1; i <= 100; ++i)
{
  auto iter = theMap.find(i);
  if (iter != theMap.end())
    largest = std::max(largest, *iter);
}
```

This version of the loop is only slightly more verbose than our starting point
and avoids all of the issues, but the use of iterators and the need to call
*two* member functions (`find` and `end`) for this simple operation increases
the congestive load on the programmer and the reader. Moreover, a generic
use of `find` can yield a subtle bug.  Consider function template `f`:

```cpp
template <class Key, class Value>
void f(const Key& k, const std::map<Key, Value>& aMap)
{
  Value obj = @_some-default-obj-value-expression_@;
  auto iter = aMap.find(k);
  if (iter != aMap.end())
    obj = *iter;
  // @_code that uses_ obj@ ...
}
```

The above code will not compile unless `Value` is copy-assignable. Worse,
unless tested with a non-assignable type, the bug could go undetected for a
long time. Assuming it is detected, one fix would be initialize `obj` in a
single expression:

```cpp
Value obj = aMap.count(k) ? aMap.at(k) : @_some-default-obj-value-expression_@;
```

While correct, this solution involves two lookup operations: One for the
`count` and one for the `at`.  A better fix requires a bit more code:

```cpp
auto iter = aMap.find(k);
Value obj = iter != aMap.end() ? aMap.at(k) : @_some-default-obj-value-expression_@;
```

Proposed feature
================

Overview
--------

What's desired is a simple member function that, given a key, returns the
mapped value if the key exists and a specified alternative if the value does
not exist. Inspired by a similar member of Python dictionaries, I propose a
`get` member function for all C++ dictionary-like associative containers and
related `get_ref` and `get_as<T>` member functions. A slightly simplified set
of prototypes is:

```cpp
// @_Return by value_@
template <class... Args>
auto get(const key_type& key, Args&&... args) const -> mapped_type;

// @_Return by reference_@
template <class Arg>
auto get_ref(const key_type& key, Arg& ref)
  -> common_ref_t<mapped_type&, Arg&>;

template <class Arg>
auto get_ref(const key_type& key, Arg& ref) const
  -> common_ref_t<const mapped_type&, Arg&>;

// @_Return as a specific type_@
template <class R, class... Args>
auto get_as(const key_type& key, Args&&... args) -> R;

template <class R, class... Args>
auto get_as(const key_type& key, Args&&... args) const -> R;
```

In each case, if the key is found, the mapped value is returned, otherwise, an
alternative value is constructed from the remaining arguments and returned.
The differences between the different members is in the determination of the
return type.

The `get` member
----------------

The proposed `get` member is the simplest to use and is suitable for most types
having inexpensive copy constructors.  If the key is found, the mapped value is
returned *by value*, otherwise the return value is constructed from `args`. If
`args` is an empty pack, then the return value is default constructed.

Returning by value is not as expensive as it once was, as the materialization
rules (formerly *copy elision*) means that fewer temporaries are
created. Moreover, the alternative value can be a literal prvalue such as `-1`
or `nullptr`.

The `get_ref` member
--------------------


Never the less, sometimes returning the
`mapped_type` by value is not desirable. For these circumstances I propose the
`get_as` function template:

```cpp
  template <class R, class... Args>
  auto get_as(const key_type& key, Args&&... args) & -> R
```

The return type `R` is specified by the user and can be a reference type. If
the key is found in the, the return value is constructed from the mapped value,
otherwise it is constructed from `args`. Not only can `R` be a reference type,
it can be any other type constructible from the mapped_type. For example, given
a `std::map<int, std::string>`, it would be efficient to return a
`string_view`:

```cpp
std::map<int, std::string> theMap;
...
auto val = theMap.get_as<std::string_view>(n, "none");
```

The above code does not generate a temporary for the string literal `"none"`,
nor does it generate a dangling `string_view` reference to that temporary.

Comparisons
-----------



Alternatives considered
=======================

merge get and get_ref

merge get_ref and get_as -- too verbose and error prone

add rvalue overloads -- none of the other element accessors have that

free functions instead of members


Implementation Experience
=========================


Formal Wording
==============
