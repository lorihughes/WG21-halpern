% D2946R0: A flexible solution to the problems of `noexcept`
% Pablo Halpern <<phalpern@halpernwightsoftware.com>>
% <!-- $TimeStamp$ -->2023-07-08 16:52 EDT<!-- $ -->
Target audience: EWGI

<head>

<style type="text/css">
  body { max-width: 54em; }
  ins { text-decoration:none; background-color:#A0FFA0 }
  .new { text-decoration:none; background-color:#D0FFD0 }
  del { text-decoration:line-through; background-color:#FFA0A0 }
  strong { font-weight: inherit; color: #2020ff }
  table, td, th { border: 1px solid black; border-collapse:collapse; padding: 5px }
  blockquote { margin: 1em 0 1em 1.7em; padding-left: 1em; border-left: 0; }
  pre { left-margin: 50px; line-height: 1.1; }
  pre code { font-size: 80%; }
  del pre code { text-decoration: inherit; background-color:#FFA0A0 }
  ins pre code { text-decoration: inherit; background-color:#A0FFA0 }
</style>
</head>

Abstract
========

The `noexcept` function annotation and companion `noexcept` operator were
invented to allow containers such `vector` to provide the strong exception
guarantee when performing operations that require relocating existing
elements. The `noexcept` annotation has since been utilized to improve code
generation and, sometimes, as a form of documentation.  The problems with these
off-label uses have been known for a long time; the so-called *Lakos Rule* was
intended to prevent such use (or misuse) within the C++ Standard Library.  In
this paper, I propose an annotation for non-throwing functions to be used
instead of `noexcept` in circumstances where the latter is undesirable --
specifically, when the function in question has a *narrow contract*.  Although
not part of the simple and minimal proposal presented, this paper also explores
how this alternative nothrow facility could eventually be integrated with a
future contracts facility.

Brief Summary
=============

I propose an annotation, e.g., `[[throws_nothing]]`, indicating that a
function does not throw when called correctly (*in contract*). Unlike
`noexcept` the `[[throws_nothing]]` annotation cannot be detected by the
`noexcept` operator:

```C++
void f(int) [[throws_nothing]];
static_assert(noexcept(f(0)) == false);
```

Thus, `[[throws_nothing]]` can be added or removed from a function declaration
without affecting program logic.

Motivation
==========

Purpose of `noexcept`
---------------------

The `noexcept` specifier was introduced at the end of the C++11 cycle for one
purpose: to enable the safe use of move constructors in `vector`-like
containers that offer the *strong exception guarantee* for some operations.
Below is an approximate implementation of a vector-reallocation function, which
must leave the original vector unchanged if an exception is thrown while trying
to move elements from the old buffer to the new one.

```C++
template <class T, class A>
void vector<T,A>::reallocate(size_type new_capacity)
{
  pointer new_data = allocator_traits<A>::allocate(new_capacity);

  size_type i = 0;
  if constexpr (noexcept(T(std::move(m_data[i]))))
    for (i = 0; i < size(); ++i)
      new (&new_data[i]) T(std::move(m_data[i]));  // Move (efficient)
  }
  else try {
    for (i = 0; i < size(); ++i)
      new (&new_data[i]) T(m_data[i]);  // Copy (less efficient)
  }
  catch (...) {
    while (i)
      new_data[--i].~T();
    allocator_traits<A>::deallocate(new_data, new_capacity);
    throw;
  }

  // Got here only if no exception was thrown
  for (i = 0; i < size(); ++i)
    m_data[i].~T();
  allocator_traits<A>::deallocate(m_data, m_capacity);

  m_data     = new_data;
  m_capacity = new_capacity;
}
```

The use of `T`'s move constructor often yields significant performance
advantages over using its copy constructor, but the move constructor modifies
the original object; if the move constructor might throw, `vector` must revert
to the copy constructor, giving up the performance gain in order to ensure that
it can return the original object to its initial state. In the absence of
`noexcept`, it would be impossible to retain the strong guarantee while using
`std::move` in the code above.

The Lakos Rule
--------------

Being late in the C++11 cycle, applying the brand-new, and not fully
understood, `noexcept` annotation appropriately in the standard library was a
challenge. John Lakos proposed, and the committee accepted, what has become
known as the *Lakos Rule*.  Summarized below, the Lakos Rule provided a safe
framework for deciding whether or not a specific function should be declared
`noexcept`.

 * If it has no preconditions (a *wide contract*) and it does not
   throw, then declare it `noexcept`.
 * If it has preconditions (a *narrow contract*) or it might
   throw when called correctly (*in contract*), then do not declare it
   `noexcept` (or declare it `noexcept(false)`).

In the example below, showing a subset of the `std::vector` interface, `size()`
is declared `noexcept` whereas `at` and `operator[]` are not.

```C++
template <class T, class A>
class vector {
   // ...
   constexpr size_type size() noexcept;       // wide contract,   doesn't throw
   constexpr reference at(size_type);         // wide contract,   might throw
   constexpr reference operator[](size_type); // narrow contract, doesn't throw
};
```

Resistance to the Lakos Rule
----------------------------

Although it is an effective rule, with strong theoretical and practical
underpinnings (see [Lakos23]()), two reasons have emerged for violating the
Lakos Rule in the Standard Library design:

 1. Under many (but not all) circumstances, calling a `noexcept` function
    generates less code.  Thus, programmers -- both within and outside of WG21
    -- want to use `noexcept` to improve code generation.

 2. Within WG21, it irks some people that a function is marked "*Throws*:
    nothing", yet does not have a `noexcept` annotation.

As tempting as it might be, violating the Lakos rule is usually ill-advised. As
described in [Lakos23](), if `noexcept` is added to a function in one version
of the Standard, it cannot be removed in future versions without breaking code.
It is safe to widen the contract of a function to add new functionality,
provided that the new version is *Liskov Subtitutable* for the old one. If the
old version is annotated with `noexcept`, however, the new version cannot be
widened to accept new values that would result in an exception being thrown.

Moveover, a defensive programming library or language contract facility might
want to throw an exception on a contract violation, especially when testing the
contract checks themselves.  `noexcept` interferes with such a facility (see
[Doumler23]()).

The feature proposed by this paper is intended to provide the desired
code-generation and documentation benefits described above without violating
spirit or letter of the Lakos Rule.


Proposed Feature
================

I propose a standard attribute, tentatively named `[[throws_nothing]]`, to
indicate that a function does not throw when called in contract. The behavior
of such a function would be *implementation defined* if an attempt is made to
exit the function via a thrown exception.  By making the behavior
implementation defined, rather than specifying an action such as
`std::terminate()` or letting the behavior be undefined, we allow the behavior
to vary based on optimization level or other compiler settings (*build modes*).

Critical to the `[[throws_nothing]]` feature is that it cannot be detected by
the program itself at compile time; the result of the `noexcept` operator is
unchanged by this attribute. It does not change the type of the function and it
cannot be used to change an algorithm at compile time.

`[[throws_nothing]]` does not change the behavior of a correct program and can
be removed in future versions of a function, provided the behavior of the
function does not change for any previously valid inputs.

As with `noexcept`, implementations of the Standard Library would be permitted
to use `[[throws_nothing]]` for any non-throwing function, even if the Standard
itself does not mandate its use.

Advantages over no annotation
-----------------------------

When a function having a narrow contract does not throw when called in
contract, using the `[[throws_nothing]]` attribute provides the following
advantages over using no annotation at all:

* Documents the nonthrowing nature of the function

* Allows the compiler to generate smaller (and occasionally faster) code

* Allows the compiler to generate safer code by, e.g., terminating the program
  if an exception is thrown.

Advantages over `noexcept`
--------------------------

When a function having a narrow contract does not throw when called in
contract, using the `[[throws_nothing]]` attribute provides the following
advantages over the `noexcept` annotation:

* Future-compatible with future versions of the same function that might throw
  when called in contract

* Allows for build modes where defensive checks might throw, allowing programs
  to "recover" from logic errors (or at least fail more gracefully)

* Clearly distinguishes a algorithm-level nothrow specification from one that
  exists only as a performance hint to the compiler.

* Does not violate the Lakos Rule

Build modes
-----------

Build modes are not part of the C++ standard, but their existence can be
implied. Initially, it would expected (and encouraged) that every implementation
provide at least two build modes affecting the behavior of attempting to exit
a `[[throws_nothing]]` function via an exception:

1. **Terminate**: Call `std::terminate` just like `noexcept` does.

2. **Ignore/rethrow**: Allow the exception to escape, as though the annotation
   were not present.

There are other options, some of which are described in the
[Future Integration with Contracts](#future-integration-with-contracts)
section, below.

Syntax and spelling
-------------------

The `[[throws_nothing]]` attribute proposed here would be allowed in the same
location as `noexcept`.  In fact, it might make sense to use them together,
especially for conditional `noexcept` clauses. Although this syntactic location
seems intuitive to me, I am open to arguments that it should go somewhere else,
such as at the start of a function declaration.

The `[[throws_nothing]]` annotation fits well with the conventional notion of
an attribute: removing the attribute has no essential effect on a correct
program. I am open to the idea, however, that it should be a keyword or
contextual keyword.

Some alternative spellings have been considered:

* `[[does_not_throw]]`
* `throws_nothing` (keyword or contextual keyword)
* `does_not_throw` (keyword or contextual keyword)

This paper does not propose the ability to make `[[does_not_throw]]`
conditional a constant (Boolean) property, the way the `noexcept` clause can.  If
that functionality is desired (now or in the future), the syntax can be
extended with a parameter, i.e., `[[does_not_throw(` *boolean-expression* `)]]`.

Alternatives Considered
=======================

Switching `noexcept` on and off with a constant expression
----------------------------------------------------------

One use of `[[does_not_throw]]` is to allow defensive checks to throw an
exception through an otherwise-nonthrowing interface. One proposed way to get
this behavior in certain build modes is to use `noexcept` in such a way that it
can be turned off for certain functions.  This approach can be implemented with
help of the preprocessor:

```C++
#ifdef CHECKED_MODE
inline constexpr bool does_not_throw = false;
#define ASSERT(cond) if (! (cond)) throw std::logic_error(#cond)
#else
inline constexpr bool does_not_throw = true;
#define ASSERT(cond) (void) 0
#endif

void f(int i) noexcept(does_not_throw)  // BAD IDEA!
{
  ASSERT(i < 0);
  // ...
}
```

The problem with this approach is that the expression `noexcept(f(0))` will
yield different results in different build modes, possibly resulting in
different logic paths for debug and release builds.

Extending the `noexcept` syntax
-------------------------------

Instead of a separate attribute or keyword, the `noexcept` annotation could be
extended in some way.  For example, instead of a Boolean argument, a
three-state argument could be used to specify `noexcept(true)`,
`noexcept(false)`, or `[[throws_nothing]]` semantics.

Alternatively, a new token could be inserted into or around `noxcept`, e.g.,
`noexcept(true, uncheckable)`.

While these spellings achieve the goals of this paper, they seem weird and hard
to specify. They do, however, have the advantage of unifying the two
similar-but-not-identical features.


Future Integration with Contracts
=================================

As the contract facility takes shape, we would want to ensure that the
`[[throws_nothing]]` facility evolves in such a way as to make the combination
as powerful and consistent as possible.  Specifically,

* `[[throws_nothing]]` describes a sort of postcondition, i.e., that the
   function did not exit via an exception. If possible, its syntax should be
   harmonious with contract annotations. If the latter uses a non-attribute
   syntax, then *throws-nothing* should use a similar syntax (assuming the two
   features first ship in the same standard).

* Related to the preceding, an exception trying to escape a
  `[[throws_nothing]]` function, should be treated as a contract violation,
  resulting in a call to the violation handler.  Thus, in addition to propagate
  or terminate, an integrated facility would also have a convert-to-violation
  mode.

* In a build mode where contract-checks are enabled and a throwing
  contract-violation handler is installed, `[[throws_nothing]]` should allow
  exceptions to escape the function.  A high-quality implementation would
  recognize the interaction such that exceptions thrown from the
  contract-violation handler are propagated unchanged and other exceptions are
  converted into contract violations.

* If contract annotations are given additional controls, many of those controls
  should also apply to `[[throws_nothing]]`:

```C++
void f(int) [[ throws_nothing ]];          // Obey global build mode
void g(int) [[ throws_nothing audit ]];    // Only observed in audit build mode
void h(int) [[ throws_nothing enforce ]];  // Always enforced
void j(int) [[ throws_nothing assume ]];   // Assume no-throw; don't check
```

The last example (function `j`) would generate the smallest code because
neither the caller nor callee would need to generate any exception-handling
code. It is also the least safe because, just as in the case of other contract
annotations, assuming something that turns out to be false will typically
result in undefined behavior.

Affects on the Standard library
===============================

No changes would be needed immediately in the Standard Library if this facility
were adopted. If LWG wants to, it can use the new annotation instead of, or in
addition to "*Throws*: nothing" for functions having narrow contracts that
don't throw when called in contract.

The one place where immediate change might be necessary is that if there are
any narrow-contract functions targeted for C++26 that are currently annotated
with `noexcept`, we probably want to change those annotations to
`[[throws_nothing]]`.


Implementation Experience
=========================

At present, no compilers implement this feature. If this paper receives a
favorable response in EWGI, we will make sure to implement it before presenting
it to EWG. Implementation is expected to be a fairly simple delta on the
existing implementation of `noexcept`.


Formal wording
==============

TBD: Wording will be provided after EWGI shows initial interest, i.e., after a
positive result in an "encourages more work" poll.
